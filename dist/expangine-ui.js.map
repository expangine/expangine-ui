{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/external \"expangine-runtime\"","webpack://[name]/external \"expangine-runtime-live\"","webpack://[name]/./functions.ts","webpack://[name]/./ComponentRegistry.ts","webpack://[name]/../node_modules/scrute/lib/Constants.js","webpack://[name]/../node_modules/scrute/lib/Node.js","webpack://[name]/../node_modules/scrute/lib/Dependency.js","webpack://[name]/../node_modules/scrute/lib/Watcher.js","webpack://[name]/../node_modules/scrute/lib/Link.js","webpack://[name]/../node_modules/scrute/lib/handler.js","webpack://[name]/../node_modules/scrute/lib/observe.js","webpack://[name]/../node_modules/scrute/lib/Observer.js","webpack://[name]/../node_modules/scrute/lib/watch.js","webpack://[name]/./Scope.ts","webpack://[name]/../node_modules/scrute/lib/unobserve.js","webpack://[name]/./ComponentInstance.ts","webpack://[name]/./compile.ts","webpack://[name]/./constants.ts","webpack://[name]/./Node.ts","webpack://[name]/./compilers/default.ts","webpack://[name]/./compilers/visibility.ts","webpack://[name]/./compilers/index.ts","webpack://[name]/./compilers/dynamic.ts","webpack://[name]/./compilers/component.ts","webpack://[name]/./compilers/if.ts","webpack://[name]/./compilers/slots.ts","webpack://[name]/./compilers/for.ts","webpack://[name]/./index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createScope","copyProperties","createChildScope","parent","child","target","source","prop","ComponentRegistry","ARRAY_CHANGES","ARRAY_ITERATIONS","Node","this","next","prev","forEach","iterator","curr","index","toArray","out","item","push","insertAfter","last","remove","isEmpty","head","Dependency","observer","links","notify","notifyParent","deep","link","watcher","destroy","liveWatchers","Watcher","expression","immediate","dirty","paused","evaluating","isWatching","update","off","result","pop","onResult","pause","resume","Link","dependency","watcherNode","dependencyNode","existing","handler","_reciever","val","obs","Array","copy","slice","apply","arguments","max","Math","length","deepNotified","handleArrayChange","handleWatching","handleArrayIteration","set","deleteProperty","dep","isObservable","isObserved","observe","input","_a","_b","proxy","Proxy","revocable","revoke","writable","configurable","Observer","deps","watch","expr","_c","_d","data","observed","disables","watchers","children","addToParent","attr","defaultValue","values","onValue","cmd","eval","node","extra","w","enable","disable","enabled","Number","MAX_SAFE_INTEGER","unobserve","x","component","slots","cache","scope","listeners","eventName","payload","listener","indexOf","splice","updated","element","RootComponent","collection","attributes","events","render","getCompiler","template","tag","compilers","compile","mount","page","replace","rootScope","refs","instance","default","compiled","parentElement","e","insertBefore","removeChild","isStyleElement","style","getSlots","isNamedSlots","isArray","changeElement","replaceChild","nextSibling","appendChild","createChildNodes","childScope","scopes","document","createTextNode","textNode","text","textContent","childNode","childElement","setMany","CompilerVisibility","attrs","childSlots","show","placeholder","createComment","substring","createChild","childTemplate","condition","Error","controller","visible","newVisible","visibleBoolean","isVisible","previous","desired","display","setEnabled","createElement","attrValue","isWatchable","v","setAttribute","ev","eventValue","addEventListener","nativeEvent","childs","childController","lastInstance","tagValue","dynamicInstance","parentComponent","id","componentBase","undefined","rendered","localScope","ref","attrObject","type","attrInput","first","initial","changed","state","localState","stateName","on","created","slotName","slotScope","scopeKey","scopeValue","itemTemplate","items","propItem","propIndex","map","Map","newChildren","keys","Set","itemIndex","itemScopeData","itemKey","itemController","updateScopes","itemScope","add","entryValue","entryKey","has","destroyScopes","delete"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,qBAAsBA,QAAQ,2BACtC,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,oBAAqB,0BAA2BJ,GAC9B,iBAAZC,QACdA,QAAQ,gBAAkBD,EAAQG,QAAQ,qBAAsBA,QAAQ,2BAExEJ,EAAK,gBAAkBC,EAAQD,EAAK,qBAAsBA,EAAK,2BARjE,CASGO,QAAQ,SAASC,EAAgCC,GACpD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUV,QAGnC,IAAIC,EAASO,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHZ,QAAS,IAUV,OANAa,EAAQH,GAAUI,KAAKb,EAAOD,QAASC,EAAQA,EAAOD,QAASS,GAG/DR,EAAOW,GAAI,EAGJX,EAAOD,QA0Df,OArDAS,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASjB,EAASkB,EAAMC,GAC3CV,EAAoBW,EAAEpB,EAASkB,IAClCG,OAAOC,eAAetB,EAASkB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASzB,GACX,oBAAX0B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAetB,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAetB,EAAS,aAAc,CAAE4B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASnC,GAChC,IAAIkB,EAASlB,GAAUA,EAAO8B,WAC7B,WAAwB,OAAO9B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAQ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrDzC,EAAOD,QAAUM,G,cCAjBL,EAAOD,QAAUO,G,oCCCV,SAASoC,EAAYN,GAI1B,OAAOO,EAAe,IAFtB,aAE4CP,GAGvC,SAASQ,EAAiBC,EAAaT,GAE5C,SAASU,KAGT,OAFAA,EAAMR,UAAYO,EAEXF,EAAe,IAAKG,EAAiBV,GAGvC,SAASO,EAAeI,EAAaC,GAE1C,IAAK,MAAMC,KAAQD,EAEjBD,EAAOE,GAAQD,EAAOC,GAGxB,OAAOF,E,WCrBF,MAAMG,EAA8D9B,OAAOY,OAAO,M,WCM9EmB,EAAgB,CACvB,IAAO,EACP,KAAQ,EACR,MAAS,EACT,QAAW,EACX,QAAW,EACX,OAAU,EACV,KAAQ,GAODC,EAAmB,CAC1B,OAAU,EACV,MAAS,EACT,KAAQ,EACR,OAAU,EACV,KAAQ,EACR,UAAa,EACb,QAAW,EACX,SAAY,EACZ,QAAW,EACX,KAAQ,EACR,YAAe,EACf,IAAO,EACP,OAAU,EACV,YAAe,EACf,MAAS,EACT,KAAQ,GCjCRC,EAAsB,WAMtB,SAASA,EAAK1B,GACV2B,KAAK3B,MAAQA,EACb2B,KAAKC,KAAOD,KAAKE,KAAOF,KAuE5B,OA7DAD,EAAKf,UAAUmB,QAAU,SAAUC,GAG/B,IAFA,IAAIC,EAAOL,KAAKC,KACZK,EAAQ,EACLD,IAASL,MAAM,CAClB,IAAIC,EAAOI,EAAKJ,KAChBG,EAASC,EAAKhC,MAAOgC,EAAMC,GAC3BD,EAAOJ,EACPK,IAEJ,OAAOA,GAKXP,EAAKf,UAAUuB,QAAU,WACrB,IAAIC,EAAM,GAEV,OADAR,KAAKG,SAAQ,SAAUM,GAAQ,OAAOD,EAAIE,KAAKD,MACxCD,GAOXT,EAAKf,UAAU2B,YAAc,SAAUT,GACnCF,KAAKC,KAAOC,EAAKD,KACjBD,KAAKE,KAAOA,EACZF,KAAKE,KAAKD,KAAOD,KAAKC,KAAKC,KAAOF,MAStCD,EAAKf,UAAU0B,KAAO,SAAUE,GAC5BA,EAAKD,YAAYX,KAAKE,OAK1BH,EAAKf,UAAU6B,OAAS,WACfb,KAAKc,YACNd,KAAKC,KAAKC,KAAOF,KAAKE,KACtBF,KAAKE,KAAKD,KAAOD,KAAKC,KACtBD,KAAKE,KAAOF,KAAKC,KAAOD,OAMhCD,EAAKf,UAAU8B,QAAU,WACrB,OAAOd,KAAKC,OAASD,MAKzBD,EAAKgB,KAAO,WACR,OAAO,IAAIhB,EAAK,OAEbA,EA/Ec,GCDrB,EAA4B,WAM5B,SAASiB,EAAWC,GAChBjB,KAAKiB,SAAWA,EAChBjB,KAAKkB,MAAQnB,EAAKgB,OA8BtB,OAnBAC,EAAWhC,UAAUmC,OAAS,SAAUC,QACf,IAAjBA,IAA2BA,GAAe,GAC9C,IAAIC,GAAO,EASX,OAPArB,KAAKkB,MAAMX,UAAUJ,SAAQ,SAAUmB,GACnCA,EAAKC,QAAQJ,SACbE,EAAOA,GAAQC,EAAKC,QAAQF,QAE5BD,GAAgBC,GAAQrB,KAAKiB,SAAS1B,QACtCS,KAAKiB,SAAS1B,OAAO4B,OAAOC,GAEzBC,GAKXL,EAAWhC,UAAUwC,QAAU,WAC3BxB,KAAKkB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOA,EAAKT,aAE9CG,EAtCoB,GCApBS,EAAe,GAMtB,EAAyB,WAKzB,SAASC,EAAQC,EAAYC,EAAWP,QAClB,IAAdO,IAAwBA,GAAY,QAC3B,IAATP,IAAmBA,GAAO,GAC9BrB,KAAK2B,WAAaA,EAClB3B,KAAK4B,UAAYA,EACjB5B,KAAKqB,KAAOA,EACZrB,KAAK6B,OAAQ,EACb7B,KAAK8B,QAAS,EACd9B,KAAK+B,YAAa,EAClB/B,KAAKkB,MAAQnB,EAAKgB,OAqEtB,OA/DAW,EAAQ1C,UAAUgD,WAAa,WAC3B,OAAQhC,KAAKkB,MAAMJ,WAKvBY,EAAQ1C,UAAUmC,OAAS,WACnBnB,KAAK+B,aAGT/B,KAAK6B,OAAQ,EACT7B,KAAK4B,WACL5B,KAAKiC,WAMbP,EAAQ1C,UAAUiD,OAAS,WACvBjC,KAAK+B,YAAa,EAClB/B,KAAKkC,MACLT,EAAaf,KAAKV,MAClB,IACIA,KAAKmC,OAASnC,KAAK2B,aAEvB,QAGI,GAFAF,EAAaW,MACbpC,KAAK6B,OAAQ,EACT7B,KAAKqC,SACL,IACIrC,KAAKqC,WAET,QACIrC,KAAK+B,YAAa,EAG1B/B,KAAK+B,YAAa,IAM1BL,EAAQ1C,UAAUkD,IAAM,WACpBlC,KAAKkB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOA,EAAKT,aAKrDa,EAAQ1C,UAAUsD,MAAQ,WACjBtC,KAAK8B,SACN9B,KAAKkC,MACLlC,KAAK8B,QAAS,IAMtBJ,EAAQ1C,UAAUuD,OAAS,WACnBvC,KAAK8B,SACL9B,KAAKiC,SACLjC,KAAK8B,QAAS,IAGfJ,EAnFiB,GCJxB,EAAsB,WAItB,SAASc,EAAKjB,EAASkB,GACnBzC,KAAKuB,QAAUA,EACfvB,KAAKyC,WAAaA,EAClBzC,KAAK0C,YAAc,IAAI3C,EAAKC,MAC5BA,KAAK2C,eAAiB,IAAI5C,EAAKC,MAyBnC,OApBAwC,EAAKxD,UAAU6B,OAAS,WACpBb,KAAK0C,YAAY7B,SACjBb,KAAK2C,eAAe9B,UAQxB2B,EAAK9D,OAAS,SAAU6C,EAASkB,GAC7B,IAAIG,EAAW,KAOf,OANAH,EAAWvB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOsB,EAAYtB,EAAKC,UAAYA,EAAUD,EAAOsB,KAC3FA,IACDA,EAAW,IAAIJ,EAAKjB,EAASkB,GAC7BA,EAAWvB,MAAMR,KAAKkC,EAASD,gBAC/BpB,EAAQL,MAAMR,KAAKkC,EAASF,cAEzBE,GAEJJ,EAjCc,GCCdK,EAAU,CAKjB5E,IAAK,SAAUwB,EAAQE,EAAMmD,GACzB,IAAIC,EAAMtD,EAAOE,GACjB,GLXc,SKWVA,EACA,OAAOoD,EAEX,IAAIC,EAAMvD,EAAe,KACzB,GAAmB,mBAARsD,EAAoB,CAC3B,GAAItD,aAAkBwD,MAAO,CACzB,GAAItD,KAAQE,EACR,OA8DpB,SAA2BJ,EAAQsD,EAAKC,GACpC,OAAO,WAKH,IAJA,IAAIE,EAAOzD,EAAO0D,QACdhB,EAASY,EAAIK,MAAM3D,EAAQ4D,WAC3BC,EAAMC,KAAKD,IAAIJ,EAAKM,OAAQ/D,EAAO+D,QACnCC,GAAe,EACVrG,EAAI,EAAGA,EAAIkG,EAAKlG,IACjB8F,EAAK9F,KAAOqC,EAAOrC,KACnBqG,EAAeA,GAAgBT,EAAI7B,OAAO/D,IAE1CA,GAAKqC,EAAO+D,QACZR,EAAInC,OAAOzD,GASnB,OANIqC,EAAO+D,SAAWN,EAAKM,SACvBC,EAAeA,GAAgBT,EAAI7B,OAAO,WAE1CsC,GAAgBT,EAAIzD,QACpByD,EAAIzD,OAAO4B,QAAO,GAEfgB,GAlFYuB,CAAkBjE,EAAQsD,EAAKC,GAE1C,GAAIrD,KAAQG,EACR,OA6CpB,SAA8BL,EAAQsD,EAAKC,GACvC,OAAO,WAEH,IADA,IAAIQ,EAAS/D,EAAO+D,OACXpG,EAAI,EAAGA,EAAIoG,EAAQpG,IACxBuG,EAAelE,EAAQrC,EAAGqC,EAAOrC,GAAI4F,GAGzC,OADAW,EAAelE,EAAQ,SAAUA,EAAO+D,OAAQR,GACzCD,EAAIK,MAAM3D,EAAQ4D,YApDNO,CAAqBnE,EAAQsD,EAAKC,GAGjD,OAAOD,EAEX,OAAOY,EAAelE,EAAQE,EAAMoD,EAAKC,IAK7Ca,IAAK,SAAUpE,EAAQE,EAAMtB,EAAOyE,GAC5BzE,IAAUoB,EAAOE,KACjBF,EAAOE,GAAQtB,EACLoB,EAAe,KACrB0B,OAAOxB,GAAM,IAErB,OAAO,GAMXmE,eAAgB,SAAUrE,EAAQE,GAG9B,OAFUF,EAAe,KACrBoB,OAAOlB,IACJ,IAQf,SAASgE,EAAelE,EAAQE,EAAMoD,EAAKC,GACvC,IAAIe,EAAMf,EAAIe,IAAIpE,GAKlB,OAJA8B,EAAatB,SAAQ,SAAUoB,GAAW,OAAO,EAAK7C,OAAO6C,EAASwC,MAClEC,EAAajB,KAASkB,EAAWlB,KACjCtD,EAAOE,GAAQoD,EAAMmB,EAAQnB,EAAK,CAAExD,OAAQwE,KAEzChB,ECnDJ,SAASmB,EAAQC,EAAOC,GAC3B,IAAIC,QAAa,IAAPD,EAAgB,GAAKA,GAAI7E,OAAQA,OAAgB,IAAP8E,EAAgB,KAAOA,EAC3E,GAAIL,EAAaG,KACRA,EAAc,KAAG,CAClB,IAAIG,EAAQC,MAAMC,UAAUL,EAAOtB,GACnCsB,EAAQG,EAAMA,MACdxG,OAAOC,eAAeoG,ENfZ,OMe6B,CACnC9F,MAAO,IAAI,EAASiG,EAAMG,OAAQlF,GAClCmF,UAAU,EACVC,cAAc,EACd3G,YAAY,IAIxB,OAAOmG,EAOJ,SAASH,EAAaG,GACzB,QAA2B,iBAAVA,GAAgC,OAAVA,GAOpC,SAASF,EAAWE,GACvB,QAA2B,iBAAVA,GAAgC,OAAVA,IAAkBA,EAAc,MClC3E,IAAI,EAA0B,WAM1B,SAASS,EAASH,EAAQlF,QACP,IAAXA,IAAqBA,EAAS,MAClCS,KAAKyE,OAASA,EACdzE,KAAKT,OAASA,EACdS,KAAK6E,KAAO/G,OAAOY,OAAO,MA4E9B,OApEAkG,EAAS5F,UAAU+E,IAAM,SAAUpE,GAC/B,IAAIoE,EAAM/D,KAAK6E,KAAKlF,GAIpB,OAHKoE,IACD/D,KAAK6E,KAAKlF,GAAQoE,EAAM,IAAI,EAAW/D,OAEpC+D,GAYXa,EAAS5F,UAAUmC,OAAS,SAAUxB,EAAMyB,QACnB,IAAjBA,IAA2BA,GAAe,GAC9C,IAAIyD,EAAO7E,KAAK6E,KAChB,OAAIlF,KAAQkF,EACDA,EAAKlF,GAAMwB,OAAOC,IAEpBA,GAAgBpB,KAAKT,QAC1BS,KAAKT,OAAO4B,OAAOC,IAEhB,IASXwD,EAAS5F,UAAU6B,OAAS,SAAUlB,GAClC,IAAIkF,EAAO7E,KAAK6E,KACZlF,KAAQkF,IACRA,EAAKlF,GAAM6B,iBACJqD,EAAKlF,KAUpBiF,EAAS5F,UAAUwC,QAAU,SAAU/B,EAAQ4B,EAAMoD,QACpC,IAATpD,IAAmBA,GAAO,QACf,IAAXoD,IAAqBA,GAAS,GAClC,IAAII,EAAO7E,KAAK6E,KAChB,IAAK,IAAIlF,KAAQkF,EAGb,GAFAA,EAAKlF,GAAM6B,iBACJqD,EAAKlF,GACR0B,EAAM,CACN,IAAIhD,EAAQoB,EAAOE,GACnB,GAAIsE,EAAW5F,GACDA,EAAc,KACpBmD,QAAQnD,EAAOgD,EAAMoD,GAIjCA,GACAzE,KAAKyE,UAGNG,EAtFkB,GCMtB,SAASE,EAAMC,EAAMX,GACxB,IAAIC,OAAY,IAAPD,EAAgB,GAAKA,EAAIY,EAAKX,EAAGzC,UAAWA,OAAmB,IAAPoD,GAAuBA,EAAIC,EAAKZ,EAAGhD,KAChGE,EAAU,IAAI,EAAQwD,EAAMnD,OADwF,IAAPqD,GAAwBA,GAGzI,OADA1D,EAAQU,SACDV,ECXJ,MAAM,EAWX,YAAmBhC,EAAuB,KAAM2F,EAAY,IAE1DlF,KAAKT,OAASA,EACdS,KAAKkF,KAAO3F,EAASD,EAAiBC,EAAO2F,KAAMA,GAAQ9F,EAAY8F,GACvElF,KAAKmF,SAAWjB,EAAQlE,KAAKkF,MAC7BlF,KAAKoF,SAAW,EAChBpF,KAAKsB,KAAO,IAAI,EAAWtB,MAC3BA,KAAKqF,SAAW,EAAWtE,OAGtB,cAEDf,KAAKT,SAEFS,KAAKT,OAAO+F,WACftF,KAAKT,OAAO+F,SAAW,EAAWvE,QAEpCf,KAAKsB,KAAKX,YAAYX,KAAKT,OAAO+F,WAI/B,YAAYJ,EAAY,GAAIK,GAAuB,GAExD,MAAM/F,EAAQ,IAAI,EAAMQ,KAAMkF,GAO9B,OALIK,GAEF/F,EAAM+F,cAGD/F,EAGF,IAAuBgG,EAASC,GAErC,OAAOD,KAAQxF,KAAKmF,SAAWnF,KAAKmF,SAASK,GAAQC,EAGhD,IAAuBD,EAASnH,GAErC2B,KAAKmF,SAASK,GAAQnH,EAGjB,QAAQqH,GAEbrG,EAAeW,KAAKmF,SAAUO,GAGzB,MAAMX,EAAWY,GAEtB,MAAMC,EAAM,cAAYC,KAAKd,GAEvBxD,EAAUuD,EAAM,KACpBa,EAAQC,EAAI5F,KAAKmF,aAGbW,EAAO,IAAI,EAAWvE,GAI5B,OAFAuE,EAAKnF,YAAYX,KAAKqF,UAEf,KACL9D,EAAQW,MACR4D,EAAKjF,UAIF,KAAKkE,GAEV,MAAMa,EAAM,cAAYC,KAAKd,GAE7B,OAAQgB,GAAUH,EAAIG,EAAQ,OAAD,wBAAM/F,KAAKkF,MAASa,GAAS/F,KAAKkF,MAG1D,SAEDlF,KAAKoF,SAAW,IAElBpF,KAAKoF,WAEiB,IAAlBpF,KAAKoF,UAEPpF,KAAKqF,SAASlF,QAAS6F,GAAMA,EAAEzD,UAE7BvC,KAAKsF,UAEPtF,KAAKsF,SAASnF,QAAS1C,GAAMA,EAAEwI,WAK9B,UAEiB,IAAlBjG,KAAKoF,UAEPpF,KAAKqF,SAASlF,QAAS6F,GAAMA,EAAE1D,SAE7BtC,KAAKsF,UAEPtF,KAAKsF,SAASnF,QAAS1C,GAAMA,EAAEyI,WAGjClG,KAAKoF,WAGA,WAAWe,GAEhBA,EAAUnG,KAAKiG,SAAWjG,KAAKkG,UAG1B,UAELlG,KAAKsB,KAAKT,SACVb,KAAKoF,SAAWgB,OAAOC,iBACvBrG,KAAKqF,SAASlF,QAAS6F,GAAMA,EAAE9D,OAE3BlC,KAAKsF,UAEPtF,KAAKsF,SAASnF,QAAS1C,GAAMA,EAAE+D,WC5H9B,SAAmB2C,EAAO9C,EAAMG,GAGnC,QAFa,IAATH,IAAmBA,GAAO,QACd,IAAZG,IAAsBA,GAAU,GAChCyC,EAAWE,GAAQ,CACnB,IAAInB,EAAMmB,EAAc,YACjBA,EAAc,KACrBnB,EAAIxB,QAAQ2C,EAAO9C,EAAMG,IDyH7B8E,CAAUtG,KAAKmF,UAGV,mBAAmBoB,GAExB,OAAO,kBAAQA,IAAMA,aAAa,cE1I/B,MAAM,EAUX,YAAmBC,EAA+BC,EAAgClH,GAC9ES,KAAKwG,UAAYA,EACjBxG,KAAK0G,MAAQ5I,OAAOY,OAAO,MAC3BsB,KAAK2G,MAAQ,IAAI,EAAMpH,EAASA,EAAOoH,MAAQ,MAC/C3G,KAAKyG,MAAQA,EACbzG,KAAKT,OAASA,EACdS,KAAK4G,UAAY9I,OAAOY,OAAO,MAG5B,QAA2BmI,EAAcC,GACxCD,KAAa7G,KAAK4G,WAClB5G,KAAK4G,UAAUC,GAAW1G,QAAS9C,GAAMA,EAAEyJ,IAI5C,GAAsBD,EAAcE,GAMvC,OALMF,KAAa7G,KAAK4G,YACpB5G,KAAK4G,UAAUC,GAAa,IAEhC7G,KAAK4G,UAAUC,GAAWnG,KAAKqG,GAExB,KACH,MAAM3J,EAAI4C,KAAK4G,UAAUC,GAAWG,QAAQD,IACjC,IAAP3J,GACA4C,KAAK4G,UAAUC,GAAWI,OAAO7J,EAAG,IAKzC,SACC4C,KAAKwG,UAAUU,SAAWlH,KAAK8F,MAC/B9F,KAAKwG,UAAUU,QAAQlH,KAAMA,KAAK8F,KAAKqB,SAIxC,UAIA,UACHnH,KAAK2G,MAAMnF,UACXxB,KAAK4G,UAAY9I,OAAOY,OAAO,OC7C9B,MAAM0I,EAA2C,CACtDC,WAAY,YACZ1J,KAAM,OACN2J,WAAY,GACZC,OAAQ,GACRd,MAAO,GACPe,OAAQ,IAAM,CAAC,QAAS,GAAI,GAAI,KAG3B,SAASC,EAAYC,GAExB,MAAOC,GAAOD,EACR/I,EAAM,mBAASgJ,GACfA,KAAOC,EACHD,EACAA,KAAO/H,ECtBa,aAFF,IACA,WD4B5B,OAAOgI,EAAUjJ,GAGd,SAASkJ,EAAQH,EAAwBlB,EAA6CG,EAAcpH,GAEvG,OAAOkI,EAAYC,EAAZD,CAAsBC,EAAUlB,EAAWG,EAAOpH,GAGtD,SAASuI,EAAMC,EAAWL,EAAwBM,GAErD,MAAMC,EAAY,IAAI,EAAM,KAAM,CAAEF,OAAMG,KAAM,KAE1CC,EAAW,IAAI,EAAkBf,EAAe,CAAEgB,QAASV,IAC3DW,EAAWR,EAAQH,EAAUS,EAAUF,GAE7C,GAAID,EAAQM,cAAe,CACvB,IAAK,MAAMC,KAAKF,EAASlB,QACrBa,EAAQM,cAAcE,aAAaD,EAAGP,GAE1CA,EAAQM,cAAcG,YAAYT,GAKtC,OAFAG,EAASrC,KAAOuC,EAETF,EEpBJ,SAASO,EAAenC,GAE3B,QAASA,GAAK,mBAASA,EAAEoC,OAGtB,SAASC,EAASnC,EAA2B9I,EDvCxB,WCyC1B,OAAQ8I,EAEJ,kBAAQA,GACNA,EACA,mBAASA,IAAUA,EAAM9I,GACvB,CAAC8I,EAAM9I,IACP,GALJ,GASC,SAASkL,EAAaxK,GAE3B,MAAwB,iBAAVA,IAAuB4E,MAAM6F,QAAQzK,GAG9C,SAAS0K,EAAcZ,EAAwBhB,GAEpD,IAAK,IAAI/J,EAAI,EAAGA,EAAI+J,EAAQ3D,OAAQpG,IACpC,CACE,MAAMyB,EAAIsI,EAAQ/J,GACZS,EAAIsK,EAAShB,QAAQ/J,GAE3B,GAAIS,IAAMgB,EAKV,GAAIhB,GAAKA,EAAEyK,cAETzK,EAAEyK,cAAcU,aAAanK,EAAGhB,GAChCsK,EAAShB,QAAQ/J,GAAKyB,OAEnB,IAAKhB,GAAKT,EAAI,EACnB,CACE,MAAM8C,EAAOiI,EAAShB,QAAQ/J,EAAI,GAC5B6C,EAAOC,EAAK+I,YAEdhJ,GAAQA,EAAKqI,cAEfrI,EAAKqI,cAAcE,aAAa3J,EAAGoB,IAE3BA,GAAQC,GAAQA,EAAKoI,eAE7BpI,EAAKoI,cAAcY,YAAYrK,GAGjCsJ,EAAShB,QAAQ/J,GAAKyB,GAI1B,IAAK,IAAIzB,EAAI+K,EAAShB,QAAQ3D,OAAS,EAAGpG,GAAK+J,EAAQ3D,OAAQpG,IAC/D,CACE,MAAMS,EAAIsK,EAAShB,QAAQ/J,GAEvBS,EAAEyK,eAEJzK,EAAEyK,cAAcG,YAAY5K,GAG9BsK,EAAShB,QAAQF,OAAO7J,EAAG,IAWxB,SAAS+L,EAAiB7D,EAA+BqB,EAAcH,EAA6C4C,EAAmBjB,GAE5I,MAAMhB,EAAkB,GAClBkC,EAAkB,GAExB,IAAK,MAAM7J,KAAS8F,EAElB,GAAI,mBAAS9F,GAEX2H,EAAQzG,KAAK4I,SAASC,eAAe/J,SAElC,GAAIA,aAAiB,aAC1B,CACE,MAAMgK,EAAWF,SAASC,eAAe,IAEzC5C,EAAM7B,MAAMtF,EAAQiK,IAElBD,EAASE,YAAcD,IAGzBtC,EAAQzG,KAAK8I,OAGf,CACE,MAAMG,EAAY9B,EAAQrI,EAAOgH,EAAW4C,EAAYjB,GAExD,IAAK,MAAMyB,KAAgBD,EAAUxC,QAEnCA,EAAQzG,KAAKkJ,GAGfP,EAAO3I,KAAKiJ,EAAUhD,OAEjBwB,EAAS7C,SAMZ6C,EAAS7C,SAAS5E,KAAKiJ,GAJvBxB,EAAS7C,SAAW,CAACqE,GAS3B,MAAO,CACLxC,UACA,aAAazB,GACX,IAAK,MAAMvG,KAAKkK,EACdlK,EAAE0K,QAAQnE,IAGd,gBACE,IAAK,MAAMvG,KAAKkK,EACdlK,EAAEqC,YChKH,MCCMsI,EAAmC,CAACpC,EAAUlB,EAAWG,EAAOpH,KAE3E,MAAOoI,EAAKoC,EAAO,CAAEC,GAActC,EAC7BuC,EHHsB,UGGftC,EACPuC,EAAc,CAACZ,SAASa,cAAexC,EAAeyC,UAAU,KAEhEjC,EAAyB,CAAE5I,SAAQiH,YAAWG,QAAOQ,QADnC+C,EAAY/G,SAE9BiG,EAAazC,EAAM0D,cACnBC,EAAgB1B,EAASoB,GAE/B,KAAID,GAASA,EAAMQ,WAAaD,GAqC9B,MAAM,IAAIE,MAAM,OAAO7C,mEApCzB,CACE,MAAM8C,EAAatB,EAAiBmB,EAAe3D,EAAOH,EAAW4C,EAAYjB,GAEjF,IAAIuC,EAEJ/D,EAAM7B,MAAMiF,EAAMQ,UAAYI,IAE5B,MAAMC,IAAmBD,EAEzB,GAAID,IAAYE,EAChB,CACEF,EAAUE,EAEV,MAAMC,EAAaH,IAAYT,EAE/B,GAAI,mBAASK,GACb,CACE,MAAMQ,EAAW3C,EAAShB,QACpB4D,EAAUF,EAAYJ,EAAWtD,QAAU+C,EAE7CY,IAAaC,GAEfhC,EAAcZ,EAAU4C,QAGnBrC,EAAeP,EAAShB,WAE/BgB,EAAShB,QAAQwB,MAAMqC,QAAUH,EAAY,GAAK,QAGpDzB,EAAW6B,WAAWJ,MAS5B,OAAO1C,GC5CIP,EAA0C,CACrD,IFR2C,CAACF,EAAUlB,EAAWG,EAAOpH,KAEtE,MAAOoI,EAAKoC,EAAOxC,EAAQyC,GAActC,EACnCP,EAAUmC,SAAS4B,cAAcvD,GACjCQ,EAAyB,CAAEhB,QAAS,CAACA,GAAUX,YAAWG,QAAOpH,UAEvE,GAAI,mBAASwK,GAET,IAAK,MAAMvE,KAAQuE,EACnB,CACI,MAAMoB,EAAYpB,EAAMvE,GAEpB,EAAM4F,YAAYD,GAElB3E,EAAUG,MAAM7B,MAAMqG,EAAYE,IAE9BlE,EAAQmE,aAAa9F,EAAM6F,KAK/BlE,EAAQmE,aAAa9F,EAAM2F,GAKvC,GAAI,mBAAS5D,GAET,IAAK,MAAMgE,KAAMhE,EACjB,CACI,MAAMiE,EAAajE,EAAOgE,GAE1B,GAAI,qBAAWC,GAEXrE,EAAQsE,iBAAiBF,EAAIC,OAGjC,CACI,MAAMzE,EAAWJ,EAAMd,KAAK2F,GAG5BrE,EAAQsE,iBAAiBF,EAAKG,IAE1B,IAAmB,IAAf3E,IAEA,OAAO,KAO3B,MAAM4E,EAAU/C,EAASoB,GAEzB,GAAI2B,EAAOnI,OAAS,EACpB,CACE,MAAMoI,EAAkBzC,EAAiBwC,EAAQhF,EAAOH,EAAWG,EAAOwB,GAE1E,IAAK,MAAM3I,KAASoM,EAAgBzE,QAElCA,EAAQ+B,YAAY1J,GAIxB,OAAO2I,GEvDT,WCV2C,CAACT,EAAUlB,EAAWG,EAAOpH,KAEtE,MAAOoI,GAAOD,EACRS,EAAyB,CAAE5I,SAAQiH,YAAWG,QAAOQ,QAAS,CAACmC,SAASa,cAAc,aAC5F,IAAI0B,EAkBJ,OAhBArF,EAAUG,MAAM7B,MAAM6C,EAAMmE,IAExBpE,EAAS,GAAKoE,EAEVD,GAEAA,EAAalF,MAAMnF,UAGvB,MAAMuK,EAAkBlE,EAAQH,EAAUlB,EAAWG,EAAOpH,GAE5DwJ,EAAcZ,EAAU4D,EAAgB5E,SAExC0E,EAAeE,IAGZ5D,GDXT,aEP6C,CAACT,EAAUsE,EAAiBrF,EAAOpH,KAE9E,MAAO0M,EAAIlC,EAAOxC,EAAQyC,GAActC,EAClCwE,EAAgBtM,EAAkBqM,GAClCzF,EAAY,IAAI,EAAkB0F,EAAerD,EAAamB,GAAcA,OAAamC,EAAWH,GACpGI,EAAWF,EAAc1E,OAAOhB,GAChC6F,EAAa1F,EAAM0D,YAAY,CAAErK,KAAMwG,EAAW0B,KAAM,KACxDC,EAAWN,EAAQuE,EAAU5F,EAAW6F,EAAY9M,GAU1D,GARIoH,GAASA,EAAMzB,KAAKgD,MAAQgE,EAAcI,MAE1C3F,EAAMzB,KAAKgD,KAAKgE,EAAcI,KAAO9F,GAGzCA,EAAUV,KAAOqC,EACjB3B,EAAUG,MAAQ0F,EAEdH,EAAc5E,WAEd,IAAK,MAAM9B,KAAQ0G,EAAc5E,WACjC,CACI,MAAM6D,EAAYe,EAAc5E,WAAW9B,GACrC+G,EAAapB,aAAqB,OAClC,CAAEqB,KAAMrB,GACRA,EAEAsB,EAAY1C,GAASvE,KAAQuE,EAAQA,EAAMvE,GAAQ+G,EAAWnE,QAEpE,GAAI,EAAMgD,YAAYqB,GACtB,CACI,IAAIC,GAAQ,EAEZ/F,EAAM7B,MAAM2H,EAAYpB,IAEpBgB,EAAWxI,IAAI2B,EAAM6F,GAEjBlD,EAAShB,UAELuF,GAASH,EAAWI,QAEpBJ,EAAWI,QAAQtB,EAAG7E,EAAW2B,EAAShB,UAEpCuF,GAASH,EAAWK,SAE1BL,EAAWK,QAAQvB,EAAG7E,EAAW2B,EAAShB,SAE1CoF,EAAWtK,QAEXsK,EAAWtK,OAAOoJ,EAAG7E,EAAW2B,EAAShB,UAExCuF,GAASR,EAAchF,SAExBgF,EAAchF,QAAQV,EAAW2B,EAAShB,UAIlDuF,GAAQ,SAKZL,EAAWxI,IAAI2B,EAAMiH,GAKjC,GAAIP,EAAcW,MAClB,CACI,MAAMC,EAAanG,EAAMd,KAAKqG,EAAcW,MAAzBlG,GAEnB,GAAI,mBAASmG,GAET,IAAK,MAAMC,KAAaD,EAEpBT,EAAWxI,IAAIkJ,EAAWD,EAAWC,IAKjD,GAAI,mBAASxF,IAAW2E,EAAc3E,OAElC,IAAK,MAAMgE,KAAMhE,EACjB,CACI,KAAMgE,KAAMW,EAAc3E,QAEtB,SAGJ,MAAMiE,EAAajE,EAAOgE,GAE1B,GAAI,EAAMH,YAAYI,GACtB,CACI,MAAMzE,EAAWsF,EAAWxG,KAAK2F,GAEjChF,EAAUwG,GAAGzB,EAAIxE,IAU7B,OALImF,EAAce,SAAW9E,EAAShB,SAElC+E,EAAce,QAAQzG,EAAW2B,EAAShB,SAGvCgB,GFhGT,MGbsC,CAACT,EAAUlB,EAAWG,EAAOpH,KAEnE,MAAO,CAAEwK,EAAO,CAAEC,GAActC,EAC1BwC,EAAc,CAACZ,SAASa,cAAc,OAEtChC,EAAyB,CAAE5I,SAAQiH,YAAWG,QAAOQ,QADnC+C,EAAY/G,SAE9BiG,EAAazC,EAAM0D,cACnBC,EAAgB1B,EAASoB,GAE/B,KAAID,GAASA,EAAMQ,WAAaD,GA4B9B,MAAM,IAAIE,MAAM,wEA3BlB,CACE,MAAMC,EAAatB,EAAiBmB,EAAe3D,EAAOH,EAAW4C,EAAYjB,GAEjF,IAAIuC,GAAU,EAEd/D,EAAM7B,MAAMiF,EAAMQ,UAAYI,IAE5B,MAAMC,IAAmBD,EAEzB,GAAID,IAAYE,EAChB,CACEF,EAAUE,EAEV,MAAME,EAAW3C,EAAShB,QACpB4D,EAAUL,EAAUD,EAAWtD,QAAU+C,EAE3CY,IAAaC,GAEfhC,EAAcZ,EAAU4C,GAG1B3B,EAAW6B,WAAWP,MAS5B,OAAOvC,GH1BP,QAAkB2B,EAClB,QAAkBA,EAClB,QIdwC,CAACpC,EAAUlB,EAAWG,EAAOpH,KAEnE,MAAO,CAAEwK,EAAO,CAAEC,GAActC,EAE1BS,EAAyB,CAAE5I,SAAQiH,YAAWG,QAAOQ,QAD3C,CAACmC,SAASa,cAAc,UAGxC,GAAIJ,EACJ,CACI,MAAMmD,EAAWnD,EAAMpM,MRZH,UQadwP,EAAYxG,EAAM0D,cAClB5D,EAAQmC,EAASpC,EAAUC,MAAOyG,IAAatE,EAASoB,EAAYkD,GAE1E,GAAInD,EAAMpD,MAER,IAAK,MAAMyG,KAAYD,EACvB,CACE,MAAME,EAAaF,EAAUC,GAEzB,EAAMhC,YAAYiC,GAEpB1G,EAAM7B,MAAMuI,EAAahP,IAEvB8O,EAAUtJ,IAAIuJ,EAAUC,KAK1BF,EAAUtJ,IAAIuJ,EAAUC,GAK9B,GAAI5G,EACJ,CACE,MAAMgE,EAAatB,EAAiB1C,EAAOE,EAAOH,EAAW2G,EAAWhF,GAExEA,EAAShB,QAAUsD,EAAWtD,SAIpC,OAAOgB,GJzBT,OKjBuC,CAACT,EAAUlB,EAAWG,EAAOpH,KAElE,MAAO,CAAEwK,EAAO,CAAEC,GAActC,EAC1BwC,EAAcZ,SAASa,cAAc,OAErChC,EAAyB,CAAE5I,SAAQiH,YAAWG,QAAOQ,QAD3C,CAAC+C,IAEXoD,EAAe1E,EAASoB,GAE9B,GAAID,GAASA,EAAMwD,OAAShO,EAC5B,CACI,MAAMiO,EAAWzD,EAAMtJ,MAAQ,OACzBgN,EAAY1D,EAAMzJ,OAAS,QAC3B3B,EAAMgI,EAAMd,KAAKkE,EAAMpL,KACvB+O,EAAM,IAAIC,IAEhBhH,EAAM7B,MAAMiF,EAAMwD,MAAQA,IAEtB,MAAMK,EAAsB,CAAC1D,GACvB2D,EAAO,IAAIC,IAEjB,IAAK,IAAIC,EAAY,EAAGA,EAAYR,EAAM/J,OAAQuK,IAClD,CACI,MAAMtN,EAAO8M,EAAMQ,GACbC,EAAgB,CAAE,CAACR,GAAW/M,EAAM,CAACgN,GAAYM,GACjDE,EAAUtP,EAAIqP,GACpB,IAAIE,EAAiBR,EAAIzP,IAAIgQ,GAE7B,GAAKC,EAUDA,EAAeC,aAAaH,OAThC,CACI,MAAMI,EAAYzH,EAAM0D,YAAY2D,GAEpCE,EAAiB/E,EAAiBmE,EAAcc,EAAW5H,EAAW4H,EAAWjG,GAEjFuF,EAAI7J,IAAIoK,EAASC,GAOrBL,EAAKQ,IAAIJ,GACTL,EAAYlN,QAAQwN,EAAe/G,SAGvC4B,EAAcZ,EAAUyF,GAExBF,EAAIvN,QAAQ,CAACmO,EAAYC,KAEhBV,EAAKW,IAAID,KAEVD,EAAWG,gBAEXf,EAAIgB,OAAOH,QAM3B,OAAOpG,IC5DX,uCVA4B,aUA5B,2CVCgC,OUDhC,2CVEgC,cUFhC,6CVGkC,gBUHlC,uCVI4B,SUJ5B,yCVK8B,WUL9B,yCVM8B,WUN9B,wCVO6B,UUP7B,yCVQ8B,WUR9B","file":"expangine-ui.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"expangine-runtime\", \"expangine-runtime-live\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"expangine-ui\"] = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse\n\t\troot[\"expangine-ui\"] = factory(root[\"expangine-runtime\"], root[\"expangine-runtime-live\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","\nexport function createScope(object: any)\n{\n  function scope() { /* not empty */ }\n\n  return copyProperties(new (scope as any)(), object);\n}\n\nexport function createChildScope(parent: any, object: any) \n{\n  function child() { /* not empty */ }\n  child.prototype = parent;\n\n  return copyProperties(new (child as any)(), object);\n}\n\nexport function copyProperties(target: any, source: any)\n{\n  for (const prop in source)\n  {\n    target[prop] = source[prop];\n  }\n\n  return target;\n}","import { Component } from './Component';\n\nexport const ComponentRegistry: Record<string, Component<any, any, any>> = Object.create(null);","/**\n * The hidden property which stores the reference to the Observer for an object.\n */\nexport var PROPERTY = '$obs';\n/**\n * This is a map of array functions which modify the contents of an array. When\n * this happens the observed array is checked for referential and length changes.\n */\nexport var ARRAY_CHANGES = {\n    'pop': 1,\n    'push': 1,\n    'shift': 1,\n    'unshift': 1,\n    'reverse': 1,\n    'splice': 1,\n    'sort': 1,\n};\n/**\n * This is a map of array functions which can return different results when the\n * array is modified with the above functions. When these functions are called\n * the watch function observes all items in the array and it's length.\n */\nexport var ARRAY_ITERATIONS = {\n    'concat': 1,\n    'every': 1,\n    'fill': 1,\n    'filter': 1,\n    'find': 1,\n    'findIndex': 1,\n    'forEach': 1,\n    'includes': 1,\n    'indexOf': 1,\n    'join': 1,\n    'lastIndexOf': 1,\n    'map': 1,\n    'reduce': 1,\n    'reduceRight': 1,\n    'slice': 1,\n    'some': 1,\n};\n//# sourceMappingURL=Constants.js.map","/**\n * A node in a doubly-linked list. The functions in this class are mostly\n * intended for use by the head node. A default head node points to itself and\n * has a null value. A node always has a next or previous node reference.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Creates a new node given a value.\n     *\n     * @param value The value for the node.\n     */\n    function Node(value) {\n        this.value = value;\n        this.next = this.prev = this;\n    }\n    /**\n     * Iterates over the nodes in the linked list and returns the number of nodes\n     * in the list.\n     *\n     * @param iterator The function to call with the value of the node, the\n     *    reference to the node (useful for removing the value from the list),\n     *    and the index of the value in the list starting at the next node.\n     */\n    Node.prototype.forEach = function (iterator) {\n        var curr = this.next;\n        var index = 0;\n        while (curr !== this) {\n            var next = curr.next;\n            iterator(curr.value, curr, index);\n            curr = next;\n            index++;\n        }\n        return index;\n    };\n    /**\n     * Returns the items in this list as an array.\n     */\n    Node.prototype.toArray = function () {\n        var out = [];\n        this.forEach(function (item) { return out.push(item); });\n        return out;\n    };\n    /**\n     * Inserts this Node after the given node.\n     *\n     * @param prev The node to insert this Node after.\n     */\n    Node.prototype.insertAfter = function (prev) {\n        this.next = prev.next;\n        this.prev = prev;\n        this.prev.next = this.next.prev = this;\n    };\n    /**\n     * If this is the head of a list, this function adds a node to the very end\n     * of the list. This is also equivalent to adding the given node directly\n     * before this node.\n     *\n     * @param last The node to insert at the end of the list / before this node.\n     */\n    Node.prototype.push = function (last) {\n        last.insertAfter(this.prev);\n    };\n    /**\n     * If this Node is in a list, it removes itself from the list.\n     */\n    Node.prototype.remove = function () {\n        if (!this.isEmpty()) {\n            this.next.prev = this.prev;\n            this.prev.next = this.next;\n            this.prev = this.next = this;\n        }\n    };\n    /**\n     * Returns whether the list this node is in is empty.\n     */\n    Node.prototype.isEmpty = function () {\n        return this.next === this;\n    };\n    /**\n     * Returns a new node for the head of the list.\n     */\n    Node.head = function () {\n        return new Node(null);\n    };\n    return Node;\n}());\nexport { Node };\n//# sourceMappingURL=Node.js.map","import { Node } from './Node';\n/**\n * A dependency is a property of an object or an item in an array.\n */\nvar Dependency = /** @class */ (function () {\n    /**\n     * Creates a new Dependency.\n     *\n     * @param observer The observer for the object.\n     */\n    function Dependency(observer) {\n        this.observer = observer;\n        this.links = Node.head();\n    }\n    /**\n     * Notifies all observing watchers that this dependency has changed. If any\n     * of the watchers are watching for deep (sub) changes the parent dependency\n     * is notified.\n     *\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Dependency.prototype.notify = function (notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deep = false;\n        // We need to iterate over a copy, otherwise it could get stuck in an infinite loop.\n        this.links.toArray().forEach(function (link) {\n            link.watcher.notify();\n            deep = deep || link.watcher.deep;\n        });\n        if (notifyParent && deep && this.observer.parent) {\n            this.observer.parent.notify(notifyParent);\n        }\n        return deep;\n    };\n    /**\n     * Destroys the depdendency removing it from all watchers.\n     */\n    Dependency.prototype.destroy = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    return Dependency;\n}());\nexport { Dependency };\n//# sourceMappingURL=Dependency.js.map","import { Node } from './Node';\n/**\n * An array of watcher functions which are currently executing.\n */\nexport var liveWatchers = [];\n/**\n * A class which holds a user supplied function and list of observed\n * depdendencies it references. When any of those dependencies change a watcher\n * is notified.\n */\nvar Watcher = /** @class */ (function () {\n    /**\n     * Creates a new Watcher given an expression, if it's immediate, and if the\n     * watches are deep.\n     */\n    function Watcher(expression, immediate, deep) {\n        if (immediate === void 0) { immediate = true; }\n        if (deep === void 0) { deep = false; }\n        this.expression = expression;\n        this.immediate = immediate;\n        this.deep = deep;\n        this.dirty = false;\n        this.paused = false;\n        this.evaluating = false;\n        this.links = Node.head();\n    }\n    /**\n     * Determines whether the watch function is currently observing anything for\n     * changes.\n     */\n    Watcher.prototype.isWatching = function () {\n        return !this.links.isEmpty();\n    };\n    /**\n     * Notifies the watcher that a dependency has changed.\n     */\n    Watcher.prototype.notify = function () {\n        if (this.evaluating) {\n            return;\n        }\n        this.dirty = true;\n        if (this.immediate) {\n            this.update();\n        }\n    };\n    /**\n     * Executes the function and gathers a new list of dependencies.\n     */\n    Watcher.prototype.update = function () {\n        this.evaluating = true;\n        this.off();\n        liveWatchers.push(this);\n        try {\n            this.result = this.expression();\n        }\n        finally {\n            liveWatchers.pop();\n            this.dirty = false;\n            if (this.onResult) {\n                try {\n                    this.onResult();\n                }\n                finally {\n                    this.evaluating = false;\n                }\n            }\n            this.evaluating = false;\n        }\n    };\n    /**\n     * Stops watching for changes.\n     */\n    Watcher.prototype.off = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    /**\n     * Stops watching for changes and marks the watcher as paused.\n     */\n    Watcher.prototype.pause = function () {\n        if (!this.paused) {\n            this.off();\n            this.paused = true;\n        }\n    };\n    /**\n     * Resumes watching for changes if the watcher was paused.\n     */\n    Watcher.prototype.resume = function () {\n        if (this.paused) {\n            this.update();\n            this.paused = false;\n        }\n    };\n    return Watcher;\n}());\nexport { Watcher };\n//# sourceMappingURL=Watcher.js.map","import { Node } from './Node';\n/**\n * A relationship between a Watcher and Dependency which stores both links so\n * the lists stored in the watcher and dependency can both be removed from\n * instantly.\n */\nvar Link = /** @class */ (function () {\n    /**\n     * Creates a new Link given the Watcher and Dependency.\n     */\n    function Link(watcher, dependency) {\n        this.watcher = watcher;\n        this.dependency = dependency;\n        this.watcherNode = new Node(this);\n        this.dependencyNode = new Node(this);\n    }\n    /**\n     * Removes the relationship between the Watcher and Dependency.\n     */\n    Link.prototype.remove = function () {\n        this.watcherNode.remove();\n        this.dependencyNode.remove();\n    };\n    /**\n     * Creates a link between the given Watcher and Dependency. If a link already\n     * exists, then this function has no effect. If a link does not exist, one is\n     * created and added to both the dependency and watcher lists. A link\n     * reference is always returned.\n     */\n    Link.create = function (watcher, dependency) {\n        var existing = null;\n        dependency.links.forEach(function (link) { return existing = (link.watcher === watcher ? link : existing); });\n        if (!existing) {\n            existing = new Link(watcher, dependency);\n            dependency.links.push(existing.dependencyNode);\n            watcher.links.push(existing.watcherNode);\n        }\n        return existing;\n    };\n    return Link;\n}());\nexport { Link };\n//# sourceMappingURL=Link.js.map","import { PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS } from './Constants';\nimport { Link } from './Link';\nimport { liveWatchers } from './Watcher';\nimport { observe, isObservable, isObserved } from './observe';\n/**\n * The handler to pass to the Proxy constructor.\n */\nexport var handler = {\n    /**\n     * Intercepts the property getting so any watch functions can gather its list\n     * of dependencies.\n     */\n    get: function (target, prop, _reciever) {\n        var val = target[prop];\n        if (prop === PROPERTY) {\n            return val;\n        }\n        var obs = target[PROPERTY];\n        if (typeof val === 'function') {\n            if (target instanceof Array) {\n                if (prop in ARRAY_CHANGES) {\n                    return handleArrayChange(target, val, obs);\n                }\n                if (prop in ARRAY_ITERATIONS) {\n                    return handleArrayIteration(target, val, obs);\n                }\n            }\n            return val;\n        }\n        return handleWatching(target, prop, val, obs);\n    },\n    /**\n     * Intercepts the property setting so all dependent watchers are notified,\n     */\n    set: function (target, prop, value, _reciever) {\n        if (value !== target[prop]) {\n            target[prop] = value;\n            var obs = target[PROPERTY];\n            obs.notify(prop, true);\n        }\n        return true;\n    },\n    /**\n     * Intercepts the property delete operator so all dependent watchers no longer\n     * listen to changes.\n     */\n    deleteProperty: function (target, prop) {\n        var obs = target[PROPERTY];\n        obs.remove(prop);\n        return true;\n    }\n};\n/**\n * If a property on an object contains an observable object/array which is not\n * yet being observered - it is replaced with a proxy. The value of the property\n * is returned.\n */\nfunction handleWatching(target, prop, val, obs) {\n    var dep = obs.dep(prop);\n    liveWatchers.forEach(function (watcher) { return Link.create(watcher, dep); });\n    if (isObservable(val) && !isObserved(val)) {\n        target[prop] = val = observe(val, { parent: dep });\n    }\n    return val;\n}\n/**\n * Returns a function which ensures when its called that all items and the\n * length of the array is watched by any live watchers.\n */\nfunction handleArrayIteration(target, val, obs) {\n    return function () {\n        var length = target.length;\n        for (var i = 0; i < length; i++) {\n            handleWatching(target, i, target[i], obs);\n        }\n        handleWatching(target, 'length', target.length, obs);\n        return val.apply(target, arguments);\n    };\n}\n/**\n * Returns a function which notifies any watched functions of changes after a\n * mutating array operation is executed.\n */\nfunction handleArrayChange(target, val, obs) {\n    return function () {\n        var copy = target.slice();\n        var result = val.apply(target, arguments);\n        var max = Math.max(copy.length, target.length);\n        var deepNotified = false;\n        for (var i = 0; i < max; i++) {\n            if (copy[i] !== target[i]) {\n                deepNotified = deepNotified || obs.notify(i);\n            }\n            if (i >= target.length) {\n                obs.remove(i);\n            }\n        }\n        if (target.length !== copy.length) {\n            deepNotified = deepNotified || obs.notify('length');\n        }\n        if (deepNotified && obs.parent) {\n            obs.parent.notify(true);\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=handler.js.map","import { PROPERTY } from './Constants';\nimport { Observer } from './Observer';\nimport { handler } from './handler';\n/**\n * Observes the object/array if is not yet observed. An observed object is one\n * that can be used in watch functions and will trigger then when referenced\n * values in the observed object changes.\n *\n * @param input The object/array to observe for changes.\n * @returns The reference to the object/array or the Proxy if it is observable\n *    and has not yet been observed.\n */\nexport function observe(input, _a) {\n    var _b = (_a === void 0 ? {} : _a).parent, parent = _b === void 0 ? null : _b;\n    if (isObservable(input)) {\n        if (!input[PROPERTY]) {\n            var proxy = Proxy.revocable(input, handler);\n            input = proxy.proxy;\n            Object.defineProperty(input, PROPERTY, {\n                value: new Observer(proxy.revoke, parent),\n                writable: false,\n                configurable: true,\n                enumerable: false\n            });\n        }\n    }\n    return input;\n}\n/**\n * Determines whether the given input can be observed.\n *\n * @param input The input to test.\n */\nexport function isObservable(input) {\n    return !!(typeof input === 'object' && input !== null);\n}\n/**\n * Determines whether the given input is currently being observed.\n *\n * @param input The input to check for observation.\n */\nexport function isObserved(input) {\n    return !!(typeof input === 'object' && input !== null && input[PROPERTY]);\n}\n//# sourceMappingURL=observe.js.map","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\nimport { Dependency } from './Dependency';\n/**\n * An observer is for an object/array and keeps track of all watched properties.\n * If the observer belongs to a sub-object on an observed object then it has a\n * parent. This parent reference is needed for deeply watched objects.\n */\nvar Observer = /** @class */ (function () {\n    /**\n     * Creates a new Observer.\n     *\n     * @param parent An optional parent dependency.\n     */\n    function Observer(revoke, parent) {\n        if (parent === void 0) { parent = null; }\n        this.revoke = revoke;\n        this.parent = parent;\n        this.deps = Object.create(null);\n    }\n    /**\n     * Returns a Dependency for the given property and creates it if it doesn't\n     * exist already.\n     *\n     * @param prop The name of the property or the index of the array element.\n     */\n    Observer.prototype.dep = function (prop) {\n        var dep = this.deps[prop];\n        if (!dep) {\n            this.deps[prop] = dep = new Dependency(this);\n        }\n        return dep;\n    };\n    /**\n     * If the given property or array element is being watched, all watchers will\n     * be notified.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    notify of changes.\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Observer.prototype.notify = function (prop, notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deps = this.deps;\n        if (prop in deps) {\n            return deps[prop].notify(notifyParent);\n        }\n        else if (notifyParent && this.parent) {\n            this.parent.notify(notifyParent);\n        }\n        return false;\n    };\n    /**\n     * Removes the given property or array element so it's no longer observed for\n     * changes.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    cease watching on.\n     */\n    Observer.prototype.remove = function (prop) {\n        var deps = this.deps;\n        if (prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n        }\n    };\n    /**\n     * Destroys this observer by destroying all dependents.\n     *\n     * @param target The object which holds this observer.\n     * @param deep If any descendant objects should be destroyed as well.\n     * @param revoke If the proxy should be revoked, making the object unusable.\n     */\n    Observer.prototype.destroy = function (target, deep, revoke) {\n        if (deep === void 0) { deep = false; }\n        if (revoke === void 0) { revoke = true; }\n        var deps = this.deps;\n        for (var prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n            if (deep) {\n                var value = target[prop];\n                if (isObserved(value)) {\n                    var obs = value[PROPERTY];\n                    obs.destroy(value, deep, revoke);\n                }\n            }\n        }\n        if (revoke) {\n            this.revoke();\n        }\n    };\n    return Observer;\n}());\nexport { Observer };\n//# sourceMappingURL=Observer.js.map","import { Watcher } from './Watcher';\n/**\n * Given a function to execute, any observed objects/arrays which are referenced\n * in that function are tracked. If they change the given function will execute\n * again and a new list of dependencies is generated. A Watcher instance is\n * returned which can be used to pause, resume, or stop watching for changes.\n *\n * @param expr The function to execute when any referenced observed values change.\n * @param immediate If the function should executed as soon as a dependent value\n *    changes (true), or simply mark the returned Watcher instance as dirty (false).\n * @param deep If true, not only does the function execute when referenced\n *    values change, but also nested values.\n * @returns A new instance of Watcher.\n */\nexport function watch(expr, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.immediate, immediate = _c === void 0 ? true : _c, _d = _b.deep, deep = _d === void 0 ? false : _d;\n    var watcher = new Watcher(expr, immediate, deep);\n    watcher.update();\n    return watcher;\n}\n//# sourceMappingURL=watch.js.map","import { Expression, isArray } from 'expangine-runtime';\nimport { LiveContext, LiveRuntime } from 'expangine-runtime-live';\nimport { Watcher, Node as LinkedNode, observe, unobserve, watch } from 'scrute';\nimport { copyProperties, createChildScope, createScope } from './functions';\nimport { Off } from './Node';\n\n\nexport class Scope<A extends LiveContext = any> \n{\n  \n  public parent: Scope | null;\n  public data: A;\n  public observed: A;\n  public link: LinkedNode<Scope<A>>;\n  public children?: LinkedNode<Scope<A>>;\n  public disables: number;\n  public watchers: LinkedNode<Watcher>;\n  \n  public constructor(parent: Scope | null = null, data: any = {}) \n  {\n    this.parent = parent;\n    this.data = parent ? createChildScope(parent.data, data) : createScope(data);\n    this.observed = observe(this.data);\n    this.disables = 0;\n    this.link = new LinkedNode(this);\n    this.watchers = LinkedNode.head();\n  }\n\n  public addToParent() \n  {\n    if (this.parent) \n    {\n      if (!this.parent.children) {\n        this.parent.children = LinkedNode.head();\n      }\n      this.link.insertAfter(this.parent.children);\n    }\n  }\n\n  public createChild(data: any = {}, addToParent: boolean = true): Scope \n  {\n    const child = new Scope(this, data);\n\n    if (addToParent) \n    {\n      child.addToParent();\n    }\n    \n    return child;\n  }\n\n  public get<V extends keyof A>(attr: V, defaultValue?: A[V]): A[V] \n  {\n    return attr in this.observed ? this.observed[attr] : defaultValue as A[V];\n  }\n\n  public set<V extends keyof A>(attr: V, value: A[V]): void \n  {\n    this.observed[attr] = value;\n  }\n\n  public setMany(values: Partial<A>) \n  {\n    copyProperties(this.observed, values);\n  }\n\n  public watch(expr: any, onValue: (value: any) => void): Off \n  {\n    const cmd = LiveRuntime.eval(expr);\n\n    const watcher = watch(() => {\n      onValue(cmd(this.observed));\n    });\n\n    const node = new LinkedNode(watcher);\n\n    node.insertAfter(this.watchers);\n\n    return () => {\n      watcher.off();\n      node.remove();\n    };\n  }\n\n  public eval(expr: any): ((extra?: any) => any) \n  {\n    const cmd = LiveRuntime.eval(expr);\n\n    return (extra) => cmd(extra ? { ...this.data, ...extra} : this.data);\n  }\n\n  public enable(): void \n  {\n    if (this.disables > 0) \n    {\n      this.disables--;\n      \n      if (this.disables === 0) \n      {\n        this.watchers.forEach((w) => w.resume());\n      }\n      if (this.children) \n      {\n        this.children.forEach((c) => c.enable());\n      }\n    }\n  }\n\n  public disable(): void \n  {\n    if (this.disables === 0) \n    {\n      this.watchers.forEach((w) => w.pause());\n    }\n    if (this.children) \n    {\n      this.children.forEach((c) => c.disable());\n    }\n\n    this.disables++;\n  }\n\n  public setEnabled(enabled: boolean) \n  {\n    enabled ? this.enable() : this.disable();\n  }\n\n  public destroy(): void \n  {\n    this.link.remove();\n    this.disables = Number.MAX_SAFE_INTEGER;\n    this.watchers.forEach((w) => w.off());\n    \n    if (this.children) \n    {\n      this.children.forEach((c) => c.destroy());\n    }\n\n    unobserve(this.observed);\n  }\n\n  public static isWatchable(x: any): x is (Expression | any[])\n  {\n    return isArray(x) || x instanceof Expression;\n  }\n\n}\n","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\n/**\n * Stops all observations for the given variable. Optionally it can travel\n * through all descendant observers and unobserve them as well.\n *\n * @param input The possibly observed object.\n * @param deep If all descendant observers should be unobserved.\n * @param destroy If the proxy should be destroyed, making it unusable.\n * @returns The reference to the value passed to this function.\n */\nexport function unobserve(input, deep, destroy) {\n    if (deep === void 0) { deep = false; }\n    if (destroy === void 0) { destroy = true; }\n    if (isObserved(input)) {\n        var obs = input[PROPERTY];\n        delete input[PROPERTY];\n        obs.destroy(input, deep, destroy);\n    }\n    return input;\n}\n//# sourceMappingURL=unobserve.js.map","import { Scope } from './Scope';\nimport { Component } from './Component';\nimport { NodeInstance, NodeTemplateNamedSlots, Off } from './Node';\n\n\nexport class ComponentInstance<A, E, S extends string> \n{\n  public component: Component<A, E, S>;\n  public cache: Record<string, any>;\n  public scope: Scope<A>;\n  public node?: NodeInstance;\n  public parent?: ComponentInstance<any, any, any>;\n  public slots?: NodeTemplateNamedSlots;\n  public listeners: Record<keyof E, Array<(payload: any) => any>>;\n\n  public constructor(component: Component<A, E, S>, slots?: NodeTemplateNamedSlots, parent?: ComponentInstance<any, any, any>) {\n      this.component = component;\n      this.cache = Object.create(null);\n      this.scope = new Scope(parent ? parent.scope : null);\n      this.slots = slots;\n      this.parent = parent;\n      this.listeners = Object.create(null);\n  }\n\n  public trigger<K extends keyof E>(eventName: K, payload: E[K]): void {\n      if (eventName in this.listeners) {\n          this.listeners[eventName].forEach((l) => l(payload));\n      }\n  }\n\n  public on<K extends keyof E>(eventName: K, listener: (payload: E[K]) => any): Off {\n      if (!(eventName in this.listeners)){ \n          this.listeners[eventName] = [];\n      }\n      this.listeners[eventName].push(listener);\n\n      return () => {\n          const i = this.listeners[eventName].indexOf(listener);\n          if (i !== -1) {\n              this.listeners[eventName].splice(i, 1);\n          }\n      };\n  }\n\n  public update(): void {\n      if (this.component.updated && this.node) {\n          this.component.updated(this, this.node.element);\n      }\n  }\n\n  public render(): void {\n\n  }\n\n  public destroy(): void {\n      this.scope.destroy();\n      this.listeners = Object.create(null);\n  }\n}","\nimport { isString } from 'expangine-runtime';\nimport { ComponentRegistry } from './ComponentRegistry';\nimport { NodeCompiler, NodeTemplate, NodeInstance } from './Node';\nimport { Scope } from './Scope';\nimport { Component } from './Component';\nimport { ComponentInstance } from './ComponentInstance';\nimport { COMPILER_COMPONENT, COMPILER_DEFAULT, COMPILER_DYNAMIC } from './constants';\nimport { compilers } from './compilers';\n\n\nexport const RootComponent: Component<any, any, any> =  {\n  collection: 'expangine',\n  name: 'root',\n  attributes: {},\n  events: {},\n  slots: {},\n  render: () => [':slot', {}, {}, []],\n};\n\nexport function getCompiler(template: NodeTemplate): NodeCompiler  \n{\n    const [tag] = template;\n    const key = isString(tag) \n        ? tag in compilers\n            ? tag\n            : tag in ComponentRegistry\n                ? COMPILER_COMPONENT\n                : COMPILER_DEFAULT\n        : COMPILER_DYNAMIC;\n\n    return compilers[key];\n}\n\nexport function compile(template: NodeTemplate, component: ComponentInstance<any, any, any>, scope: Scope, parent?: NodeInstance): NodeInstance\n{\n    return getCompiler(template)(template, component, scope, parent);\n}\n\nexport function mount(page: any, template: NodeTemplate, replace: Node): ComponentInstance<any, any, any>\n{\n    const rootScope = new Scope(null, { page, refs: {} });\n\n    const instance = new ComponentInstance(RootComponent, { default: template });\n    const compiled = compile(template, instance, rootScope);\n\n    if (replace.parentElement) {\n        for (const e of compiled.element) {\n            replace.parentElement.insertBefore(e, replace);\n        }\n        replace.parentElement.removeChild(replace);\n    }\n\n    instance.node = compiled;\n\n    return instance;\n}","\nexport const DEFAULT_SLOT = 'default';\nexport const COMPILER_DEFAULT = '*';\nexport const COMPILER_DYNAMIC = ':dynamic';\nexport const COMPILER_COMPONENT = ':component';\nexport const DIRECTIVE_IF = ':if';\nexport const DIRECTIVE_SHOW = ':show';\nexport const DIRECTIVE_HIDE = ':hide';\nexport const DIRECTIVE_FOR = ':for';\nexport const DIRECTIVE_SLOT = ':slot';","import { Expression, isObject, isString, isArray } from 'expangine-runtime';\nimport { DEFAULT_SLOT } from './constants';\nimport { Scope } from './Scope';\nimport { ComponentInstance } from './ComponentInstance';\nimport { compile } from './compile';\n\n\nexport type Off = () => void;\nexport type NodeTemplateTag = string | Expression;\nexport type NodeTemplateValues = Record<string, Expression | any>; // when value is Expression, that expression is watched\nexport type NodeTemplateEvents = Record<string, Expression | any | ((payload: any) => any)>;\nexport type NodeTemplateChild = string | NodeTemplate | Expression;\nexport type NodeTemplateNamedSlots = Record<string, NodeTemplateChild>;\nexport type NodeTemplateSlots = NodeTemplateChild[] | NodeTemplateNamedSlots;\n\nexport type NodeTemplate = [\n  NodeTemplateTag,\n  NodeTemplateValues?,\n  NodeTemplateEvents?,\n  NodeTemplateSlots?\n];\n\n\nexport type NodeCompiler = (template: NodeTemplate, component: ComponentInstance<any, any, any>, scope: Scope, parent?: NodeInstance) => NodeInstance;\n\nexport interface NodeInstance \n{\n  parent?: NodeInstance;\n  children?: NodeInstance[];\n  component: ComponentInstance<any, any, any>;\n  element: Node[];\n  scope: Scope;\n}\n\n\nexport function isStyleElement(x: any): x is HTMLElement \n{\n    return !!x && isObject(x.style);\n}\n\nexport function getSlots(slots?: NodeTemplateSlots, name: string = DEFAULT_SLOT): NodeTemplateChild[]\n{\n  return !slots\n    ? []\n    : isArray(slots)\n      ? slots\n      : isObject(slots) && slots[name]\n        ? [slots[name]]\n        : [];\n}\n\n\nexport function isNamedSlots(value: any): value is NodeTemplateNamedSlots\n{\n  return typeof value === 'object' && !Array.isArray(value);\n}\n\nexport function changeElement(instance: NodeInstance, element: Node[])\n{\n  for (let i = 0; i < element.length; i++) \n  {\n    const n = element[i];\n    const o = instance.element[i];\n\n    if (o === n) \n    {\n      continue;\n    }\n\n    if (o && o.parentElement) \n    {\n      o.parentElement.replaceChild(n, o);\n      instance.element[i] = n;\n    } \n    else if (!o && i > 0) \n    {\n      const prev = instance.element[i - 1];\n      const next = prev.nextSibling;\n\n      if (next && next.parentElement) \n      {\n        next.parentElement.insertBefore(n, next);\n      } \n      else if (!next && prev && prev.parentElement) \n      {\n        prev.parentElement.appendChild(n);\n      }\n\n      instance.element[i] = n;\n    }\n  }\n\n  for (let i = instance.element.length - 1; i >= element.length; i--) \n  {\n    const o = instance.element[i];\n\n    if (o.parentElement) \n    {\n      o.parentElement.removeChild(o);\n    }\n\n    instance.element.splice(i, 1);\n  }\n}\n\nexport interface NodeChildrenController\n{\n  element: Node[];\n  updateScopes( values: any ): void;\n  destroyScopes(): void;\n}\n\nexport function createChildNodes(children: NodeTemplateChild[], scope: Scope, component: ComponentInstance<any, any, any>, childScope: Scope, instance: NodeInstance): NodeChildrenController\n{\n  const element: Node[] = [];\n  const scopes: Scope[] = [];\n\n  for (const child of children)\n  {\n    if (isString(child)) \n    {\n      element.push(document.createTextNode(child));\n    } \n    else if (child instanceof Expression)\n    {\n      const textNode = document.createTextNode('');\n\n      scope.watch(child, (text) =>\n      {\n        textNode.textContent = text;\n      });\n\n      element.push(textNode);\n    }\n    else \n    {\n      const childNode = compile(child, component, childScope, instance);\n\n      for (const childElement of childNode.element)\n      {\n        element.push(childElement);\n      }\n\n      scopes.push(childNode.scope);\n\n      if (!instance.children)\n      {\n        instance.children = [childNode];\n      }\n      else\n      {\n        instance.children.push(childNode);\n      }\n    }\n  }\n\n  return {\n    element,\n    updateScopes(values: any) {\n      for (const s of scopes) {\n        s.setMany(values);\n      }\n    },\n    destroyScopes() {\n      for (const s of scopes) {\n        s.destroy();\n      }\n    },\n  };\n}\n","import { isObject, isFunction } from 'expangine-runtime';\nimport { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { Scope } from '../Scope';\n\n\nexport const CompilerDefault: NodeCompiler = (template, component, scope, parent) => \n{\n    const [tag, attrs, events, childSlots] = template;\n    const element = document.createElement(tag as any) as HTMLElement;\n    const instance: NodeInstance = { element: [element], component, scope, parent };\n\n    if (isObject(attrs)) \n    {\n        for (const attr in attrs) \n        {\n            const attrValue = attrs[attr];\n\n            if (Scope.isWatchable(attrValue)) \n            {\n                component.scope.watch(attrValue, (v) => \n                {\n                    element.setAttribute(attr, v);\n                });\n            } \n            else \n            {\n                element.setAttribute(attr, attrValue);\n            }\n        }\n    }\n\n    if (isObject(events)) \n    {\n        for (const ev in events) \n        {\n            const eventValue = events[ev];\n\n            if (isFunction(eventValue)) \n            {\n                element.addEventListener(ev, eventValue);\n            } \n            else\n            { \n                const listener = scope.eval(eventValue);\n\n                // todo: prevent, stop, capture, self, once\n                element.addEventListener(ev, (nativeEvent) => \n                {\n                    if (listener() === false) \n                    {\n                        return false;\n                    }\n                });\n            }\n        }\n    }\n\n    const childs =  getSlots(childSlots);\n\n    if (childs.length > 0) \n    {\n      const childController = createChildNodes(childs, scope, component, scope, instance);\n\n      for (const child of childController.element)\n      {\n        element.appendChild(child);\n      }\n    }\n\n    return instance;\n};","import { isString } from 'expangine-runtime';\nimport { DIRECTIVE_SHOW } from '../constants';\nimport { NodeCompiler, NodeInstance, getSlots, changeElement, isStyleElement, createChildNodes } from '../Node';\n\n\n\nexport const CompilerVisibility: NodeCompiler = (template, component, scope, parent) => \n{\n  const [tag, attrs, , childSlots] = template;\n  const show = tag === DIRECTIVE_SHOW;\n  const placeholder = [document.createComment((tag as string).substring(1))];\n  const element: Node[] = placeholder.slice();\n  const instance: NodeInstance = { parent, component, scope, element };\n  const childScope = scope.createChild();\n  const childTemplate = getSlots(childSlots);\n  \n  if (attrs && attrs.condition && childTemplate) \n  {   \n    const controller = createChildNodes(childTemplate, scope, component, childScope, instance);\n  \n    let visible: boolean | undefined;\n\n    scope.watch(attrs.condition, (newVisible) => \n    {\n      const visibleBoolean = !!newVisible;\n\n      if (visible !== visibleBoolean)\n      {\n        visible = visibleBoolean;\n\n        const isVisible = (visible === show);\n\n        if (isString(childTemplate))\n        {\n          const previous = instance.element;\n          const desired = isVisible ? controller.element : placeholder;\n\n          if (previous !== desired) \n          {\n            changeElement(instance, desired);\n          }\n        }\n        else if (isStyleElement(instance.element))\n        {\n          instance.element.style.display = isVisible ? '' : 'none';\n        }\n\n        childScope.setEnabled(isVisible);\n      }           \n    });\n  }\n  else\n  {\n    throw new Error(`The ${tag} directive requires a condition attribute and a singule child.`);\n  }\n\n  return instance;\n};","import { NodeCompiler } from '../Node';\nimport { COMPILER_DEFAULT, COMPILER_DYNAMIC, COMPILER_COMPONENT, DIRECTIVE_IF, DIRECTIVE_SHOW, DIRECTIVE_HIDE, DIRECTIVE_SLOT, DIRECTIVE_FOR } from '../constants';\n\nimport { CompilerDefault } from './default';\nimport { CompilerDynamic } from './dynamic';\nimport { CompilerIf } from './if';\nimport { CompilerVisibility } from './visibility';\nimport { CompilerComponent } from './component';\nimport { CompilerSlot } from './slots';\nimport { CompilerFor } from './for';\n\n\nexport const compilers: Record<string, NodeCompiler> = {\n  [COMPILER_DEFAULT]: CompilerDefault,\n  [COMPILER_DYNAMIC]: CompilerDynamic,\n  [COMPILER_COMPONENT]: CompilerComponent,\n  [DIRECTIVE_IF]: CompilerIf,\n  [DIRECTIVE_SHOW]: CompilerVisibility,\n  [DIRECTIVE_HIDE]: CompilerVisibility,\n  [DIRECTIVE_SLOT]: CompilerSlot,\n  [DIRECTIVE_FOR]: CompilerFor,\n};\n","import { NodeCompiler, NodeInstance, changeElement } from '../Node';\nimport { compile } from '../compile';\n\n\nexport const CompilerDynamic: NodeCompiler = (template, component, scope, parent) =>\n{\n    const [tag] = template;\n    const instance: NodeInstance = { parent, component, scope, element: [document.createComment('dynamic')] };\n    let lastInstance: NodeInstance;\n\n    component.scope.watch(tag, (tagValue: any) =>\n    {\n        template[0] = tagValue;\n\n        if (lastInstance)\n        {\n            lastInstance.scope.destroy();\n        }\n\n        const dynamicInstance = compile(template, component, scope, parent);\n\n        changeElement(instance, dynamicInstance.element);\n\n        lastInstance = dynamicInstance;\n    });\n\n    return instance;\n};","import { Type, isObject } from 'expangine-runtime';\nimport { NodeCompiler, isNamedSlots } from '../Node';\nimport { Scope } from '../Scope';\nimport { ComponentRegistry } from '../ComponentRegistry';\nimport { ComponentInstance } from '../ComponentInstance';\nimport { compile } from '../compile';\n\n\nexport const CompilerComponent: NodeCompiler = (template, parentComponent, scope, parent) => \n{\n    const [id, attrs, events, childSlots] = template;\n    const componentBase = ComponentRegistry[id as string];\n    const component = new ComponentInstance(componentBase, isNamedSlots(childSlots) ? childSlots : undefined, parentComponent);\n    const rendered = componentBase.render(component);\n    const localScope = scope.createChild({ this: component, refs: {} });\n    const instance = compile(rendered, component, localScope, parent);\n\n    if (scope && scope.data.refs && componentBase.ref)\n    {\n        scope.data.refs[componentBase.ref] = component;\n    }\n\n    component.node = instance;\n    component.scope = localScope;\n\n    if (componentBase.attributes)\n    {\n        for (const attr in componentBase.attributes)\n        {\n            const attrValue = componentBase.attributes[attr];\n            const attrObject = attrValue instanceof Type\n                ? { type: attrValue }\n                : attrValue;\n\n            const attrInput = attrs && attr in attrs ? attrs[attr] : attrObject.default;\n\n            if (Scope.isWatchable(attrInput))\n            {\n                let first = true;\n\n                scope.watch(attrInput, (v) =>\n                {\n                    localScope.set(attr, v);\n\n                    if (instance.element)\n                    {\n                        if (first && attrObject.initial)\n                        {\n                            attrObject.initial(v, component, instance.element);\n                        }\n                        else if (!first && attrObject.changed)\n                        {\n                            attrObject.changed(v, component, instance.element);\n                        }\n                        if (attrObject.update)\n                        {\n                            attrObject.update(v, component, instance.element);\n                        }\n                        if (!first && componentBase.updated)\n                        {\n                            componentBase.updated(component, instance.element);\n                        }\n                    }\n                    \n                    first = false;\n                });\n            }\n            else\n            {\n                localScope.set(attr, attrInput);\n            }\n        }\n    }\n\n    if (componentBase.state)\n    {\n        const localState = scope.eval(componentBase.state)();\n\n        if (isObject(localState)) \n        {\n            for (const stateName in localState)\n            {\n                localScope.set(stateName, localState[stateName]);\n            }\n        }\n    }\n\n    if (isObject(events) && componentBase.events) \n    {\n        for (const ev in events) \n        {\n            if (!(ev in componentBase.events))\n            {\n                continue;\n            }\n\n            const eventValue = events[ev];\n\n            if (Scope.isWatchable(eventValue)) \n            {\n                const listener = localScope.eval(eventValue);\n\n                component.on(ev, listener);\n            }\n        }\n    }\n\n    if (componentBase.created && instance.element) \n    {\n        componentBase.created(component, instance.element);\n    }\n    \n    return instance;\n};","import { NodeCompiler, NodeInstance, getSlots, changeElement, createChildNodes } from '../Node';\n\n\nexport const CompilerIf: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const placeholder = [document.createComment('if')];\n  const element: Node[] = placeholder.slice();\n  const instance: NodeInstance = { parent, component, scope, element };\n  const childScope = scope.createChild();\n  const childTemplate = getSlots(childSlots);\n\n  if (attrs && attrs.condition && childTemplate) \n  {\n    const controller = createChildNodes(childTemplate, scope, component, childScope, instance);\n\n    let visible = false;\n\n    scope.watch(attrs.condition, (newVisible) => \n    {\n      const visibleBoolean = !!newVisible;\n\n      if (visible !== visibleBoolean)\n      {\n        visible = visibleBoolean;\n        \n        const previous = instance.element;\n        const desired = visible ? controller.element : placeholder;\n\n        if (previous !== desired) \n        {\n          changeElement(instance, desired);\n        }\n\n        childScope.setEnabled(visible);\n      }\n    });\n  }\n  else\n  {\n    throw new Error(`The :if directive requires a condition attribute and a single child.`);\n  }\n\n  return instance;\n};","import { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { DEFAULT_SLOT } from '../constants';\nimport { Scope } from '../Scope';\n\n\nexport const CompilerSlot: NodeCompiler = (template, component, scope, parent) => \n{\n    const [, attrs, , childSlots] = template;\n    const element = [document.createComment('slot')];\n    const instance: NodeInstance = { parent, component, scope, element };\n\n    if (attrs)\n    {\n        const slotName = attrs.name || DEFAULT_SLOT;\n        const slotScope = scope.createChild();\n        const slots = getSlots(component.slots, slotName) || getSlots(childSlots, slotName);\n        \n        if (attrs.scope)\n        {\n          for (const scopeKey in slotScope)\n          {\n            const scopeValue = slotScope[scopeKey];\n\n            if (Scope.isWatchable(scopeValue))\n            {\n              scope.watch(scopeValue, (value) =>\n              {\n                slotScope.set(scopeKey, scopeValue);\n              });\n            }\n            else\n            {\n              slotScope.set(scopeKey, scopeValue);\n            }\n          }\n        }\n\n        if (slots)\n        {\n          const controller = createChildNodes(slots, scope, component, slotScope, instance);\n\n          instance.element = controller.element;\n        }\n    }\n\n    return instance;\n};","import { NodeCompiler, NodeInstance, NodeChildrenController, getSlots, createChildNodes, changeElement } from '../Node';\n\n\nexport const CompilerFor: NodeCompiler = (template, component, scope, parent) => \n{\n    const [, attrs, , childSlots] = template;\n    const placeholder = document.createComment('for');\n    const element = [placeholder];\n    const instance: NodeInstance = { parent, component, scope, element };\n    const itemTemplate = getSlots(childSlots);\n\n    if (attrs && attrs.items && parent)\n    {\n        const propItem = attrs.item || 'item';\n        const propIndex = attrs.index || 'index';\n        const key = scope.eval(attrs.key);\n        const map = new Map<any, NodeChildrenController>();\n\n        scope.watch(attrs.items, (items) =>\n        {\n            const newChildren: Node[] = [placeholder];\n            const keys = new Set();\n\n            for (let itemIndex = 0; itemIndex < items.length; itemIndex++)\n            {\n                const item = items[itemIndex];\n                const itemScopeData = { [propItem]: item, [propIndex]: itemIndex };\n                const itemKey = key(itemScopeData);\n                let itemController = map.get(itemKey);\n\n                if (!itemController)\n                {\n                    const itemScope = scope.createChild(itemScopeData);\n\n                    itemController = createChildNodes(itemTemplate, itemScope, component, itemScope, instance);\n\n                    map.set(itemKey, itemController);\n                }\n                else\n                {\n                    itemController.updateScopes(itemScopeData);\n                }\n\n                keys.add(itemKey);\n                newChildren.push(...itemController.element);\n            }\n\n            changeElement(instance, newChildren);\n\n            map.forEach((entryValue, entryKey) => \n            {\n                if (!keys.has(entryKey)) \n                {\n                    entryValue.destroyScopes();\n\n                    map.delete(entryKey);\n                }\n            });\n        });\n    }\n\n    return instance;\n};","\nexport * from './constants';\nexport * from './functions';\nexport * from './compilers';\nexport * from './compile';\nexport * from './Node';\nexport * from './Scope';\nexport * from './Component';\nexport * from './ComponentInstance';\nexport * from './ComponentRegistry';"],"sourceRoot":""}