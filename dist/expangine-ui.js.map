{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/external \"expangine-runtime\"","webpack://[name]/external \"expangine-runtime-live\"","webpack://[name]/./fns.ts","webpack://[name]/./ComponentRegistry.ts","webpack://[name]/../node_modules/scrute/lib/Constants.js","webpack://[name]/../node_modules/scrute/lib/Node.js","webpack://[name]/../node_modules/scrute/lib/Dependency.js","webpack://[name]/../node_modules/scrute/lib/Watcher.js","webpack://[name]/../node_modules/scrute/lib/Link.js","webpack://[name]/../node_modules/scrute/lib/handler.js","webpack://[name]/../node_modules/scrute/lib/observe.js","webpack://[name]/../node_modules/scrute/lib/Observer.js","webpack://[name]/../node_modules/scrute/lib/watch.js","webpack://[name]/./Scope.ts","webpack://[name]/../node_modules/scrute/lib/unobserve.js","webpack://[name]/./ComponentInstance.ts","webpack://[name]/./compile.ts","webpack://[name]/./constants.ts","webpack://[name]/./Node.ts","webpack://[name]/./compilers/default.ts","webpack://[name]/./compilers/visibility.ts","webpack://[name]/./compilers/index.ts","webpack://[name]/./compilers/dynamic.ts","webpack://[name]/./compilers/component.ts","webpack://[name]/./compilers/if.ts","webpack://[name]/./compilers/slots.ts","webpack://[name]/./compilers/for.ts","webpack://[name]/./index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createScope","copyProperties","createChildScope","parent","child","target","source","prop","addComponent","comp","id","ComponentRegistry","collection","ARRAY_CHANGES","ARRAY_ITERATIONS","Node","this","next","prev","forEach","iterator","curr","index","toArray","out","item","push","insertAfter","last","remove","isEmpty","head","Dependency","observer","links","notify","notifyParent","deep","link","watcher","destroy","liveWatchers","Watcher","expression","immediate","dirty","paused","evaluating","isWatching","update","off","result","pop","onResult","pause","resume","Link","dependency","watcherNode","dependencyNode","existing","handler","_reciever","val","obs","Array","copy","slice","apply","arguments","max","Math","length","deepNotified","handleArrayChange","handleWatching","handleArrayIteration","set","deleteProperty","dep","isObservable","isObserved","observe","input","_a","_b","proxy","Proxy","revocable","revoke","writable","configurable","Observer","deps","watch","expr","_c","_d","data","observed","disables","watchers","children","addToParent","attr","defaultValue","values","onValue","cmd","eval","node","extra","w","enable","disable","enabled","Number","MAX_SAFE_INTEGER","unobserve","x","component","slots","cache","scope","listeners","eventName","payload","listener","indexOf","splice","updated","element","compile","render","changeElement","getCompiler","template","tag","compilers","mount","replace","rootScope","instance","attributes","events","compiled","parentElement","e","insertBefore","removeChild","isStyleElement","style","getSlots","isNamedSlots","isArray","replaceChild","nextSibling","appendChild","createChildNodes","childScope","scopes","document","createTextNode","textNode","text","textContent","childNode","childElement","setMany","CompilerVisibility","attrs","childSlots","show","comment","substring","createChild","childTemplate","condition","Error","controller","placeholders","map","createComment","visible","newVisible","visibleBoolean","isVisible","given","place","display","setEnabled","createElement","attrValue","isWatchable","v","setAttribute","ev","eventValue","addEventListener","nativeEvent","childs","childController","lastInstance","tagValue","dynamicInstance","parentComponent","componentBase","undefined","rendered","localScope","refs","ref","attrObject","type","attrInput","default","first","initial","changed","state","localState","stateName","on","created","placeholder","desired","slotName","slotScope","scopeKey","scopeValue","itemTemplate","items","propItem","propIndex","Map","newChildren","keys","Set","itemIndex","itemScopeData","itemKey","itemController","updateScopes","itemScope","add","entryValue","entryKey","has","destroyScopes","delete"],"mappings":"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","file":"expangine-ui.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"expangine-runtime\", \"expangine-runtime-live\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"expangine-ui\"] = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse\n\t\troot[\"expangine-ui\"] = factory(root[\"expangine-runtime\"], root[\"expangine-runtime-live\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","\nexport function createScope(object: any)\n{\n  function scope() { /* not empty */ }\n\n  return copyProperties(new (scope as any)(), object);\n}\n\nexport function createChildScope(parent: any, object: any) \n{\n  function child() { /* not empty */ }\n  child.prototype = parent;\n\n  return copyProperties(new (child as any)(), object);\n}\n\nexport function copyProperties(target: any, source: any)\n{\n  for (const prop in source)\n  {\n    target[prop] = source[prop];\n  }\n\n  return target;\n}","import { Component } from './Component';\n\nexport function addComponent<A = never, E = never, S extends string = never>(comp: Component<A, E, S>, id?: string)\n{\n  ComponentRegistry[id || `${comp.collection}/${comp.name}`] = comp as any;\n}\n\nexport const ComponentRegistry: Record<string, Component<any, any, any>> = Object.create(null);","/**\n * The hidden property which stores the reference to the Observer for an object.\n */\nexport var PROPERTY = '$obs';\n/**\n * This is a map of array functions which modify the contents of an array. When\n * this happens the observed array is checked for referential and length changes.\n */\nexport var ARRAY_CHANGES = {\n    'pop': 1,\n    'push': 1,\n    'shift': 1,\n    'unshift': 1,\n    'reverse': 1,\n    'splice': 1,\n    'sort': 1,\n};\n/**\n * This is a map of array functions which can return different results when the\n * array is modified with the above functions. When these functions are called\n * the watch function observes all items in the array and it's length.\n */\nexport var ARRAY_ITERATIONS = {\n    'concat': 1,\n    'every': 1,\n    'fill': 1,\n    'filter': 1,\n    'find': 1,\n    'findIndex': 1,\n    'forEach': 1,\n    'includes': 1,\n    'indexOf': 1,\n    'join': 1,\n    'lastIndexOf': 1,\n    'map': 1,\n    'reduce': 1,\n    'reduceRight': 1,\n    'slice': 1,\n    'some': 1,\n};\n//# sourceMappingURL=Constants.js.map","/**\n * A node in a doubly-linked list. The functions in this class are mostly\n * intended for use by the head node. A default head node points to itself and\n * has a null value. A node always has a next or previous node reference.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Creates a new node given a value.\n     *\n     * @param value The value for the node.\n     */\n    function Node(value) {\n        this.value = value;\n        this.next = this.prev = this;\n    }\n    /**\n     * Iterates over the nodes in the linked list and returns the number of nodes\n     * in the list.\n     *\n     * @param iterator The function to call with the value of the node, the\n     *    reference to the node (useful for removing the value from the list),\n     *    and the index of the value in the list starting at the next node.\n     */\n    Node.prototype.forEach = function (iterator) {\n        var curr = this.next;\n        var index = 0;\n        while (curr !== this) {\n            var next = curr.next;\n            iterator(curr.value, curr, index);\n            curr = next;\n            index++;\n        }\n        return index;\n    };\n    /**\n     * Returns the items in this list as an array.\n     */\n    Node.prototype.toArray = function () {\n        var out = [];\n        this.forEach(function (item) { return out.push(item); });\n        return out;\n    };\n    /**\n     * Inserts this Node after the given node.\n     *\n     * @param prev The node to insert this Node after.\n     */\n    Node.prototype.insertAfter = function (prev) {\n        this.next = prev.next;\n        this.prev = prev;\n        this.prev.next = this.next.prev = this;\n    };\n    /**\n     * If this is the head of a list, this function adds a node to the very end\n     * of the list. This is also equivalent to adding the given node directly\n     * before this node.\n     *\n     * @param last The node to insert at the end of the list / before this node.\n     */\n    Node.prototype.push = function (last) {\n        last.insertAfter(this.prev);\n    };\n    /**\n     * If this Node is in a list, it removes itself from the list.\n     */\n    Node.prototype.remove = function () {\n        if (!this.isEmpty()) {\n            this.next.prev = this.prev;\n            this.prev.next = this.next;\n            this.prev = this.next = this;\n        }\n    };\n    /**\n     * Returns whether the list this node is in is empty.\n     */\n    Node.prototype.isEmpty = function () {\n        return this.next === this;\n    };\n    /**\n     * Returns a new node for the head of the list.\n     */\n    Node.head = function () {\n        return new Node(null);\n    };\n    return Node;\n}());\nexport { Node };\n//# sourceMappingURL=Node.js.map","import { Node } from './Node';\n/**\n * A dependency is a property of an object or an item in an array.\n */\nvar Dependency = /** @class */ (function () {\n    /**\n     * Creates a new Dependency.\n     *\n     * @param observer The observer for the object.\n     */\n    function Dependency(observer) {\n        this.observer = observer;\n        this.links = Node.head();\n    }\n    /**\n     * Notifies all observing watchers that this dependency has changed. If any\n     * of the watchers are watching for deep (sub) changes the parent dependency\n     * is notified.\n     *\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Dependency.prototype.notify = function (notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deep = false;\n        // We need to iterate over a copy, otherwise it could get stuck in an infinite loop.\n        this.links.toArray().forEach(function (link) {\n            link.watcher.notify();\n            deep = deep || link.watcher.deep;\n        });\n        if (notifyParent && deep && this.observer.parent) {\n            this.observer.parent.notify(notifyParent);\n        }\n        return deep;\n    };\n    /**\n     * Destroys the depdendency removing it from all watchers.\n     */\n    Dependency.prototype.destroy = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    return Dependency;\n}());\nexport { Dependency };\n//# sourceMappingURL=Dependency.js.map","import { Node } from './Node';\n/**\n * An array of watcher functions which are currently executing.\n */\nexport var liveWatchers = [];\n/**\n * A class which holds a user supplied function and list of observed\n * depdendencies it references. When any of those dependencies change a watcher\n * is notified.\n */\nvar Watcher = /** @class */ (function () {\n    /**\n     * Creates a new Watcher given an expression, if it's immediate, and if the\n     * watches are deep.\n     */\n    function Watcher(expression, immediate, deep) {\n        if (immediate === void 0) { immediate = true; }\n        if (deep === void 0) { deep = false; }\n        this.expression = expression;\n        this.immediate = immediate;\n        this.deep = deep;\n        this.dirty = false;\n        this.paused = false;\n        this.evaluating = false;\n        this.links = Node.head();\n    }\n    /**\n     * Determines whether the watch function is currently observing anything for\n     * changes.\n     */\n    Watcher.prototype.isWatching = function () {\n        return !this.links.isEmpty();\n    };\n    /**\n     * Notifies the watcher that a dependency has changed.\n     */\n    Watcher.prototype.notify = function () {\n        if (this.evaluating) {\n            return;\n        }\n        this.dirty = true;\n        if (this.immediate) {\n            this.update();\n        }\n    };\n    /**\n     * Executes the function and gathers a new list of dependencies.\n     */\n    Watcher.prototype.update = function () {\n        this.evaluating = true;\n        this.off();\n        liveWatchers.push(this);\n        try {\n            this.result = this.expression();\n        }\n        finally {\n            liveWatchers.pop();\n            this.dirty = false;\n            if (this.onResult) {\n                try {\n                    this.onResult();\n                }\n                finally {\n                    this.evaluating = false;\n                }\n            }\n            this.evaluating = false;\n        }\n    };\n    /**\n     * Stops watching for changes.\n     */\n    Watcher.prototype.off = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    /**\n     * Stops watching for changes and marks the watcher as paused.\n     */\n    Watcher.prototype.pause = function () {\n        if (!this.paused) {\n            this.off();\n            this.paused = true;\n        }\n    };\n    /**\n     * Resumes watching for changes if the watcher was paused.\n     */\n    Watcher.prototype.resume = function () {\n        if (this.paused) {\n            this.update();\n            this.paused = false;\n        }\n    };\n    return Watcher;\n}());\nexport { Watcher };\n//# sourceMappingURL=Watcher.js.map","import { Node } from './Node';\n/**\n * A relationship between a Watcher and Dependency which stores both links so\n * the lists stored in the watcher and dependency can both be removed from\n * instantly.\n */\nvar Link = /** @class */ (function () {\n    /**\n     * Creates a new Link given the Watcher and Dependency.\n     */\n    function Link(watcher, dependency) {\n        this.watcher = watcher;\n        this.dependency = dependency;\n        this.watcherNode = new Node(this);\n        this.dependencyNode = new Node(this);\n    }\n    /**\n     * Removes the relationship between the Watcher and Dependency.\n     */\n    Link.prototype.remove = function () {\n        this.watcherNode.remove();\n        this.dependencyNode.remove();\n    };\n    /**\n     * Creates a link between the given Watcher and Dependency. If a link already\n     * exists, then this function has no effect. If a link does not exist, one is\n     * created and added to both the dependency and watcher lists. A link\n     * reference is always returned.\n     */\n    Link.create = function (watcher, dependency) {\n        var existing = null;\n        dependency.links.forEach(function (link) { return existing = (link.watcher === watcher ? link : existing); });\n        if (!existing) {\n            existing = new Link(watcher, dependency);\n            dependency.links.push(existing.dependencyNode);\n            watcher.links.push(existing.watcherNode);\n        }\n        return existing;\n    };\n    return Link;\n}());\nexport { Link };\n//# sourceMappingURL=Link.js.map","import { PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS } from './Constants';\nimport { Link } from './Link';\nimport { liveWatchers } from './Watcher';\nimport { observe, isObservable, isObserved } from './observe';\n/**\n * The handler to pass to the Proxy constructor.\n */\nexport var handler = {\n    /**\n     * Intercepts the property getting so any watch functions can gather its list\n     * of dependencies.\n     */\n    get: function (target, prop, _reciever) {\n        var val = target[prop];\n        if (prop === PROPERTY) {\n            return val;\n        }\n        var obs = target[PROPERTY];\n        if (typeof val === 'function') {\n            if (target instanceof Array) {\n                if (prop in ARRAY_CHANGES) {\n                    return handleArrayChange(target, val, obs);\n                }\n                if (prop in ARRAY_ITERATIONS) {\n                    return handleArrayIteration(target, val, obs);\n                }\n            }\n            return val;\n        }\n        return handleWatching(target, prop, val, obs);\n    },\n    /**\n     * Intercepts the property setting so all dependent watchers are notified,\n     */\n    set: function (target, prop, value, _reciever) {\n        if (value !== target[prop]) {\n            target[prop] = value;\n            var obs = target[PROPERTY];\n            obs.notify(prop, true);\n        }\n        return true;\n    },\n    /**\n     * Intercepts the property delete operator so all dependent watchers no longer\n     * listen to changes.\n     */\n    deleteProperty: function (target, prop) {\n        var obs = target[PROPERTY];\n        obs.remove(prop);\n        return true;\n    }\n};\n/**\n * If a property on an object contains an observable object/array which is not\n * yet being observered - it is replaced with a proxy. The value of the property\n * is returned.\n */\nfunction handleWatching(target, prop, val, obs) {\n    var dep = obs.dep(prop);\n    liveWatchers.forEach(function (watcher) { return Link.create(watcher, dep); });\n    if (isObservable(val) && !isObserved(val)) {\n        target[prop] = val = observe(val, { parent: dep });\n    }\n    return val;\n}\n/**\n * Returns a function which ensures when its called that all items and the\n * length of the array is watched by any live watchers.\n */\nfunction handleArrayIteration(target, val, obs) {\n    return function () {\n        var length = target.length;\n        for (var i = 0; i < length; i++) {\n            handleWatching(target, i, target[i], obs);\n        }\n        handleWatching(target, 'length', target.length, obs);\n        return val.apply(target, arguments);\n    };\n}\n/**\n * Returns a function which notifies any watched functions of changes after a\n * mutating array operation is executed.\n */\nfunction handleArrayChange(target, val, obs) {\n    return function () {\n        var copy = target.slice();\n        var result = val.apply(target, arguments);\n        var max = Math.max(copy.length, target.length);\n        var deepNotified = false;\n        for (var i = 0; i < max; i++) {\n            if (copy[i] !== target[i]) {\n                deepNotified = deepNotified || obs.notify(i);\n            }\n            if (i >= target.length) {\n                obs.remove(i);\n            }\n        }\n        if (target.length !== copy.length) {\n            deepNotified = deepNotified || obs.notify('length');\n        }\n        if (deepNotified && obs.parent) {\n            obs.parent.notify(true);\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=handler.js.map","import { PROPERTY } from './Constants';\nimport { Observer } from './Observer';\nimport { handler } from './handler';\n/**\n * Observes the object/array if is not yet observed. An observed object is one\n * that can be used in watch functions and will trigger then when referenced\n * values in the observed object changes.\n *\n * @param input The object/array to observe for changes.\n * @returns The reference to the object/array or the Proxy if it is observable\n *    and has not yet been observed.\n */\nexport function observe(input, _a) {\n    var _b = (_a === void 0 ? {} : _a).parent, parent = _b === void 0 ? null : _b;\n    if (isObservable(input)) {\n        if (!input[PROPERTY]) {\n            var proxy = Proxy.revocable(input, handler);\n            input = proxy.proxy;\n            Object.defineProperty(input, PROPERTY, {\n                value: new Observer(proxy.revoke, parent),\n                writable: false,\n                configurable: true,\n                enumerable: false\n            });\n        }\n    }\n    return input;\n}\n/**\n * Determines whether the given input can be observed.\n *\n * @param input The input to test.\n */\nexport function isObservable(input) {\n    return !!(typeof input === 'object' && input !== null);\n}\n/**\n * Determines whether the given input is currently being observed.\n *\n * @param input The input to check for observation.\n */\nexport function isObserved(input) {\n    return !!(typeof input === 'object' && input !== null && input[PROPERTY]);\n}\n//# sourceMappingURL=observe.js.map","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\nimport { Dependency } from './Dependency';\n/**\n * An observer is for an object/array and keeps track of all watched properties.\n * If the observer belongs to a sub-object on an observed object then it has a\n * parent. This parent reference is needed for deeply watched objects.\n */\nvar Observer = /** @class */ (function () {\n    /**\n     * Creates a new Observer.\n     *\n     * @param parent An optional parent dependency.\n     */\n    function Observer(revoke, parent) {\n        if (parent === void 0) { parent = null; }\n        this.revoke = revoke;\n        this.parent = parent;\n        this.deps = Object.create(null);\n    }\n    /**\n     * Returns a Dependency for the given property and creates it if it doesn't\n     * exist already.\n     *\n     * @param prop The name of the property or the index of the array element.\n     */\n    Observer.prototype.dep = function (prop) {\n        var dep = this.deps[prop];\n        if (!dep) {\n            this.deps[prop] = dep = new Dependency(this);\n        }\n        return dep;\n    };\n    /**\n     * If the given property or array element is being watched, all watchers will\n     * be notified.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    notify of changes.\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Observer.prototype.notify = function (prop, notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deps = this.deps;\n        if (prop in deps) {\n            return deps[prop].notify(notifyParent);\n        }\n        else if (notifyParent && this.parent) {\n            this.parent.notify(notifyParent);\n        }\n        return false;\n    };\n    /**\n     * Removes the given property or array element so it's no longer observed for\n     * changes.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    cease watching on.\n     */\n    Observer.prototype.remove = function (prop) {\n        var deps = this.deps;\n        if (prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n        }\n    };\n    /**\n     * Destroys this observer by destroying all dependents.\n     *\n     * @param target The object which holds this observer.\n     * @param deep If any descendant objects should be destroyed as well.\n     * @param revoke If the proxy should be revoked, making the object unusable.\n     */\n    Observer.prototype.destroy = function (target, deep, revoke) {\n        if (deep === void 0) { deep = false; }\n        if (revoke === void 0) { revoke = true; }\n        var deps = this.deps;\n        for (var prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n            if (deep) {\n                var value = target[prop];\n                if (isObserved(value)) {\n                    var obs = value[PROPERTY];\n                    obs.destroy(value, deep, revoke);\n                }\n            }\n        }\n        if (revoke) {\n            this.revoke();\n        }\n    };\n    return Observer;\n}());\nexport { Observer };\n//# sourceMappingURL=Observer.js.map","import { Watcher } from './Watcher';\n/**\n * Given a function to execute, any observed objects/arrays which are referenced\n * in that function are tracked. If they change the given function will execute\n * again and a new list of dependencies is generated. A Watcher instance is\n * returned which can be used to pause, resume, or stop watching for changes.\n *\n * @param expr The function to execute when any referenced observed values change.\n * @param immediate If the function should executed as soon as a dependent value\n *    changes (true), or simply mark the returned Watcher instance as dirty (false).\n * @param deep If true, not only does the function execute when referenced\n *    values change, but also nested values.\n * @returns A new instance of Watcher.\n */\nexport function watch(expr, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.immediate, immediate = _c === void 0 ? true : _c, _d = _b.deep, deep = _d === void 0 ? false : _d;\n    var watcher = new Watcher(expr, immediate, deep);\n    watcher.update();\n    return watcher;\n}\n//# sourceMappingURL=watch.js.map","import { Expression, isArray } from 'expangine-runtime';\nimport { LiveContext, LiveRuntime } from 'expangine-runtime-live';\nimport { Watcher, Node as LinkedNode, observe, unobserve, watch } from 'scrute';\nimport { copyProperties, createChildScope, createScope } from './fns';\nimport { Off } from './Node';\n\n\nexport class Scope<A extends LiveContext = any> \n{\n  \n  public parent: Scope | null;\n  public data: A;\n  public observed: A;\n  public link: LinkedNode<Scope<A>>;\n  public children?: LinkedNode<Scope<A>>;\n  public disables: number;\n  public watchers: LinkedNode<Watcher>;\n  \n  public constructor(parent: Scope | null = null, data: any = {}) \n  {\n    this.parent = parent;\n    this.data = parent ? createChildScope(parent.data, data) : createScope(data);\n    this.observed = observe(this.data);\n    this.disables = 0;\n    this.link = new LinkedNode(this);\n    this.watchers = LinkedNode.head();\n  }\n\n  public addToParent() \n  {\n    if (this.parent) \n    {\n      if (!this.parent.children) {\n        this.parent.children = LinkedNode.head();\n      }\n      this.link.insertAfter(this.parent.children);\n    }\n  }\n\n  public createChild(data: any = {}, addToParent: boolean = true): Scope \n  {\n    const child = new Scope(this, data);\n\n    if (addToParent) \n    {\n      child.addToParent();\n    }\n    \n    return child;\n  }\n\n  public get<V extends keyof A>(attr: V, defaultValue?: A[V]): A[V] \n  {\n    return attr in this.observed ? this.observed[attr] : defaultValue;\n  }\n\n  public set<V extends keyof A>(attr: V, value: A[V]): void \n  {\n    this.observed[attr] = value;\n  }\n\n  public setMany(values: Partial<A>) \n  {\n    copyProperties(this.observed, values);\n  }\n\n  public watch(expr: any, onValue: (value: any) => void): Off \n  {\n    const cmd = LiveRuntime.eval(expr);\n\n    const watcher = watch(() => {\n      onValue(cmd(this.observed));\n    });\n\n    const node = new LinkedNode(watcher);\n\n    node.insertAfter(this.watchers);\n\n    return () => {\n      watcher.off();\n      node.remove();\n    };\n  }\n\n  public eval(expr: any): ((extra?: any) => any) \n  {\n    const cmd = LiveRuntime.eval(expr);\n\n    return (extra) => cmd(extra ? createChildScope(this.observed, extra) : this.observed);\n  }\n\n  public enable(): void \n  {\n    if (this.disables > 0) \n    {\n      this.disables--;\n      \n      if (this.disables === 0) \n      {\n        this.watchers.forEach((w) => w.resume());\n      }\n      if (this.children) \n      {\n        this.children.forEach((c) => c.enable());\n      }\n    }\n  }\n\n  public disable(): void \n  {\n    if (this.disables === 0) \n    {\n      this.watchers.forEach((w) => w.pause());\n    }\n    if (this.children) \n    {\n      this.children.forEach((c) => c.disable());\n    }\n\n    this.disables++;\n  }\n\n  public setEnabled(enabled: boolean) \n  {\n    enabled ? this.enable() : this.disable();\n  }\n\n  public destroy(): void \n  {\n    this.link.remove();\n    this.disables = Number.MAX_SAFE_INTEGER;\n    this.watchers.forEach((w) => w.off());\n    \n    if (this.children) \n    {\n      this.children.forEach((c) => c.destroy());\n    }\n\n    unobserve(this.observed);\n  }\n\n  public static isWatchable(x: any): x is (Expression | any[])\n  {\n    return isArray(x) || x instanceof Expression;\n  }\n\n}\n","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\n/**\n * Stops all observations for the given variable. Optionally it can travel\n * through all descendant observers and unobserve them as well.\n *\n * @param input The possibly observed object.\n * @param deep If all descendant observers should be unobserved.\n * @param destroy If the proxy should be destroyed, making it unusable.\n * @returns The reference to the value passed to this function.\n */\nexport function unobserve(input, deep, destroy) {\n    if (deep === void 0) { deep = false; }\n    if (destroy === void 0) { destroy = true; }\n    if (isObserved(input)) {\n        var obs = input[PROPERTY];\n        delete input[PROPERTY];\n        obs.destroy(input, deep, destroy);\n    }\n    return input;\n}\n//# sourceMappingURL=unobserve.js.map","import { Scope } from './Scope';\nimport { Component } from './Component';\nimport { NodeInstance, NodeTemplateNamedSlots, Off, changeElement } from './Node';\nimport { compile } from './compile';\n\n\nexport class ComponentInstance<A, E, S extends string> \n{\n  public component: Component<A, E, S>;\n  public cache: Record<string, any>;\n  public scope: Scope<A>;\n  public node?: NodeInstance;\n  public parent?: ComponentInstance<any, any, any>;\n  public slots?: NodeTemplateNamedSlots;\n  public listeners: Record<keyof E, Array<(payload: any) => any>>;\n\n  public constructor(component: Component<A, E, S>, slots?: NodeTemplateNamedSlots, parent?: ComponentInstance<any, any, any>) \n  {\n    this.component = component;\n    this.cache = Object.create(null);\n    this.scope = new Scope(parent?.scope);\n    this.slots = slots;\n    this.parent = parent;\n    this.listeners = Object.create(null);\n  }\n\n  public trigger<K extends keyof E>(eventName: K, payload: E[K]): void \n  {\n    if (eventName in this.listeners) \n    {\n      this.listeners[eventName].forEach((l) => l(payload));\n    }\n  }\n\n  public on<K extends keyof E>(eventName: K, listener: (payload: E[K]) => any): Off \n  {\n    if (!(eventName in this.listeners))\n    { \n      this.listeners[eventName] = [];\n    }\n\n    this.listeners[eventName].push(listener);\n\n    return () => \n    {\n      const i = this.listeners[eventName].indexOf(listener);\n\n      if (i !== -1) \n      {\n          this.listeners[eventName].splice(i, 1);\n      }\n    };\n  }\n\n  public update(): void \n  {\n    if (this.component.updated && this.node) \n    {\n      this.component.updated(this, this.node.element);\n    }\n  }\n\n  public render(): void \n  {\n    this.scope.destroy();\n    this.scope = new Scope(this.parent?.scope);\n    this.cache = Object.create(null);\n\n    const rendered = this.component.render(this);\n    const node = compile(rendered, this, this.scope);\n\n    changeElement(this.node, node.element);\n    \n    this.node = node;\n  }\n\n  public destroy(): void \n  {\n    this.scope.destroy();\n    this.listeners = Object.create(null);\n  }\n\n}","\nimport { isString } from 'expangine-runtime';\nimport { ComponentRegistry } from './ComponentRegistry';\nimport { NodeCompiler, NodeTemplate, NodeInstance } from './Node';\nimport { Scope } from './Scope';\nimport { ComponentInstance } from './ComponentInstance';\nimport { COMPILER_COMPONENT, COMPILER_DEFAULT, COMPILER_DYNAMIC } from './constants';\nimport { compilers } from './compilers';\n\nexport function getCompiler(template: NodeTemplate): NodeCompiler  \n{\n  const [tag] = template;\n  const key = isString(tag) \n    ? tag in compilers\n      ? tag\n      : tag in ComponentRegistry\n        ? COMPILER_COMPONENT\n        : COMPILER_DEFAULT\n    : COMPILER_DYNAMIC;\n\n  return compilers[key];\n}\n\nexport function compile(template: NodeTemplate, component: ComponentInstance<any, any, any>, scope: Scope, parent?: NodeInstance): NodeInstance\n{\n  return getCompiler(template)(template, component, scope, parent);\n}\n\nexport function mount(data: any, template: NodeTemplate, replace?: Node): ComponentInstance<any, any, any>\n{\n  const rootScope = new Scope(null, data);\n\n  const instance = new ComponentInstance<any, any, any>({\n    collection: 'expangine',\n    name: 'mounted',\n    attributes: {},\n    events: {},\n    slots: {},\n    render: () => template,\n  });\n\n  instance.scope = rootScope;\n\n  const compiled = compile(template, instance, rootScope);\n\n  if (replace && replace.parentElement) \n  {\n    for (const e of compiled.element) \n    {\n        replace.parentElement.insertBefore(e, replace);\n    }\n\n    replace.parentElement.removeChild(replace);\n  }\n\n  instance.node = compiled;\n\n  return instance;\n}","\nexport const DEFAULT_SLOT = 'default';\nexport const COMPILER_DEFAULT = '*';\nexport const COMPILER_DYNAMIC = ':dynamic';\nexport const COMPILER_COMPONENT = ':component';\nexport const DIRECTIVE_IF = ':if';\nexport const DIRECTIVE_SHOW = ':show';\nexport const DIRECTIVE_HIDE = ':hide';\nexport const DIRECTIVE_FOR = ':for';\nexport const DIRECTIVE_SLOT = ':slot';","import { Expression, isObject, isString, isArray } from 'expangine-runtime';\nimport { DEFAULT_SLOT } from './constants';\nimport { Scope } from './Scope';\nimport { ComponentInstance } from './ComponentInstance';\nimport { compile } from './compile';\n\n\nexport type Off = () => void;\nexport type NodeTemplateTag = string | Expression;\nexport type NodeTemplateValues = Record<string, Expression | any>; // when value is Expression, that expression is watched\nexport type NodeTemplateEvents = Record<string, Expression | any | ((payload: any) => any)>;\nexport type NodeTemplateChild = string | NodeTemplate | Expression;\nexport type NodeTemplateNamedSlots = Record<string, NodeTemplateChild>;\nexport type NodeTemplateSlots = NodeTemplateChild[] | NodeTemplateNamedSlots;\n\nexport type NodeTemplate = [\n  NodeTemplateTag,\n  NodeTemplateValues?,\n  NodeTemplateEvents?,\n  NodeTemplateSlots?\n];\n\n\nexport type NodeCompiler = (template: NodeTemplate, component: ComponentInstance<any, any, any>, scope: Scope, parent?: NodeInstance) => NodeInstance;\n\nexport interface NodeInstance \n{\n  parent?: NodeInstance;\n  children?: NodeInstance[];\n  component: ComponentInstance<any, any, any>;\n  element: Node[];\n  scope: Scope;\n}\n\n\nexport function isStyleElement(x: any): x is HTMLElement \n{\n  return !!x && isObject(x.style);\n}\n\nexport function getSlots(slots?: NodeTemplateSlots, name: string = DEFAULT_SLOT): NodeTemplateChild[]\n{\n  return !slots\n    ? []\n    : isArray(slots)\n      ? slots\n      : isObject(slots) && slots[name]\n        ? [slots[name]]\n        : [];\n}\n\n\nexport function isNamedSlots(value: any): value is NodeTemplateNamedSlots\n{\n  return typeof value === 'object' && !Array.isArray(value);\n}\n\nexport function changeElement(instance: NodeInstance, element: Node[])\n{\n  for (let i = 0; i < element.length; i++) \n  {\n    const n = element[i];\n    const o = instance.element[i];\n\n    if (o === n) \n    {\n      continue;\n    }\n\n    if (o) \n    {\n      if (o.parentElement)\n      {\n        o.parentElement.replaceChild(n, o);\n      }\n      \n      instance.element[i] = n;\n    } \n    else if (!o && i > 0) \n    {\n      const prev = instance.element[i - 1];\n      const next = prev.nextSibling;\n\n      if (next && next.parentElement) \n      {\n        next.parentElement.insertBefore(n, next);\n      } \n      else if (!next && prev && prev.parentElement) \n      {\n        prev.parentElement.appendChild(n);\n      }\n\n      instance.element[i] = n;\n    }\n  }\n\n  for (let i = instance.element.length - 1; i >= element.length; i--) \n  {\n    const o = instance.element[i];\n\n    if (o.parentElement) \n    {\n      o.parentElement.removeChild(o);\n    }\n\n    instance.element.splice(i, 1);\n  }\n}\n\nexport interface NodeChildrenController\n{\n  element: Node[];\n  updateScopes( values: any ): void;\n  destroyScopes(): void;\n}\n\nexport function createChildNodes(children: NodeTemplateChild[], scope: Scope, component: ComponentInstance<any, any, any>, childScope: Scope, instance: NodeInstance): NodeChildrenController\n{\n  const element: Node[] = [];\n  const scopes: Scope[] = [];\n\n  for (const child of children)\n  {\n    if (isString(child)) \n    {\n      element.push(document.createTextNode(child));\n    } \n    else if (child instanceof Expression)\n    {\n      const textNode = document.createTextNode('');\n\n      scope.watch(child, (text) =>\n      {\n        textNode.textContent = text;\n      });\n\n      element.push(textNode);\n    }\n    else \n    {\n      const childNode = compile(child, component, childScope, instance);\n\n      for (const childElement of childNode.element)\n      {\n        element.push(childElement);\n      }\n\n      scopes.push(childNode.scope);\n\n      if (!instance.children)\n      {\n        instance.children = [childNode];\n      }\n      else\n      {\n        instance.children.push(childNode);\n      }\n    }\n  }\n\n  return {\n    element,\n    updateScopes(values: any) {\n      for (const s of scopes) {\n        s.setMany(values);\n      }\n    },\n    destroyScopes() {\n      for (const s of scopes) {\n        s.destroy();\n      }\n    },\n  };\n}\n","import { isObject, isFunction } from 'expangine-runtime';\nimport { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { Scope } from '../Scope';\n\n\nexport const CompilerDefault: NodeCompiler = (template, component, scope, parent) => \n{\n  const [tag, attrs, events, childSlots] = template;\n  const element = document.createElement(tag as any) as HTMLElement;\n  const instance: NodeInstance = { element: [element], component, scope, parent };\n\n  if (isObject(attrs)) \n  {\n    for (const attr in attrs) \n    {\n      const attrValue = attrs[attr];\n\n      if (Scope.isWatchable(attrValue)) \n      {\n        scope.watch(attrValue, (v) => \n        {\n          element.setAttribute(attr, v);\n        });\n      }\n      else \n      {\n        element.setAttribute(attr, attrValue);\n      }\n    }\n  }\n\n  if (isObject(events)) \n  {\n    for (const ev in events) \n    {\n      const eventValue = events[ev];\n\n      if (isFunction(eventValue)) \n      {\n        element.addEventListener(ev, eventValue);\n      } \n      else\n      { \n        const listener = scope.eval(eventValue);\n\n        // todo: prevent, stop, capture, self, once\n        element.addEventListener(ev, (nativeEvent) => \n        { \n          if (listener() === false) \n          {\n            return false;\n          }\n        });\n      }\n    }\n  }\n\n  const childs =  getSlots(childSlots);\n\n  if (childs.length > 0) \n  {\n    const childController = createChildNodes(childs, scope, component, scope, instance);\n\n    for (const child of childController.element)\n    {\n      element.appendChild(child);\n    }\n  }\n\n  return instance;\n};","import { DIRECTIVE_SHOW } from '../constants';\nimport { NodeCompiler, NodeInstance, getSlots, isStyleElement, createChildNodes } from '../Node';\n\n\n\nexport const CompilerVisibility: NodeCompiler = (template, component, scope, parent) => \n{\n  const [tag, attrs, , childSlots] = template;\n  const show = tag === DIRECTIVE_SHOW;\n  const comment = (tag as string).substring(1);\n  const instance: NodeInstance = { parent, component, scope, element: [] };\n  const childScope = scope.createChild();\n  const childTemplate = getSlots(childSlots);\n  \n  if (attrs && attrs.condition && childTemplate) \n  {   \n    const controller = createChildNodes(childTemplate, scope, component, childScope, instance);\n    const placeholders = controller.element.map((e) => document.createComment(comment));\n    \n    instance.element = controller.element.slice();\n\n    let visible: boolean | undefined;\n\n    scope.watch(attrs.condition, (newVisible) => \n    {\n      const visibleBoolean = !!newVisible;\n\n      if (visible !== visibleBoolean)\n      {\n        visible = visibleBoolean;\n\n        const isVisible = (visible === show);\n\n        for (let i = 0; i < instance.element.length; i++)\n        {\n          const curr = instance.element[i];\n          const given = controller.element[i];\n          const place = placeholders[i];\n\n          if (isStyleElement(given))\n          {\n            given.style.display = isVisible ? '' : 'none';\n          }\n          else if (isVisible && place !== curr && place.parentElement)\n          {\n            place.parentElement.replaceChild(curr, place);\n            instance.element[i] = curr;\n          }\n          else if (!isVisible && curr !== place && curr.parentElement)\n          {\n            curr.parentElement.replaceChild(place, curr);\n            instance.element[i] = place;\n          }\n        }\n\n        childScope.setEnabled(isVisible);\n      }           \n    });\n  }\n  else\n  {\n    throw new Error(`The ${tag} directive requires a condition attribute and a singule child.`);\n  }\n\n  return instance;\n};","import { NodeCompiler } from '../Node';\nimport { COMPILER_DEFAULT, COMPILER_DYNAMIC, COMPILER_COMPONENT, DIRECTIVE_IF, DIRECTIVE_SHOW, DIRECTIVE_HIDE, DIRECTIVE_SLOT, DIRECTIVE_FOR } from '../constants';\n\nimport { CompilerDefault } from './default';\nimport { CompilerDynamic } from './dynamic';\nimport { CompilerIf } from './if';\nimport { CompilerVisibility } from './visibility';\nimport { CompilerComponent } from './component';\nimport { CompilerSlot } from './slots';\nimport { CompilerFor } from './for';\n\n\nexport const compilers: Record<string, NodeCompiler> = {\n  [COMPILER_DEFAULT]: CompilerDefault,\n  [COMPILER_DYNAMIC]: CompilerDynamic,\n  [COMPILER_COMPONENT]: CompilerComponent,\n  [DIRECTIVE_IF]: CompilerIf,\n  [DIRECTIVE_SHOW]: CompilerVisibility,\n  [DIRECTIVE_HIDE]: CompilerVisibility,\n  [DIRECTIVE_SLOT]: CompilerSlot,\n  [DIRECTIVE_FOR]: CompilerFor,\n};\n","import { NodeCompiler, NodeInstance, changeElement } from '../Node';\nimport { compile } from '../compile';\n\n\nexport const CompilerDynamic: NodeCompiler = (template, component, scope, parent) =>\n{\n  const [tag] = template;\n  const instance: NodeInstance = { parent, component, scope, element: [document.createComment('dynamic')] };\n  let lastInstance: NodeInstance;\n\n  scope.watch(tag, (tagValue: any) =>\n  {\n    template[0] = tagValue;\n\n    if (lastInstance)\n    {\n      lastInstance.scope.destroy();\n    }\n\n    const dynamicInstance = compile(template, component, scope, parent);\n\n    changeElement(instance, dynamicInstance.element);\n\n    lastInstance = dynamicInstance;\n  });\n\n  return instance;\n};","import { Type, isObject } from 'expangine-runtime';\nimport { NodeCompiler, isNamedSlots } from '../Node';\nimport { Scope } from '../Scope';\nimport { ComponentRegistry } from '../ComponentRegistry';\nimport { ComponentInstance } from '../ComponentInstance';\nimport { compile } from '../compile';\n\n\nexport const CompilerComponent: NodeCompiler = (template, parentComponent, scope, parent) => \n{\n  const [id, attrs, events, childSlots] = template;\n  const componentBase = ComponentRegistry[id as string];\n  const component = new ComponentInstance(componentBase, isNamedSlots(childSlots) ? childSlots : undefined, parentComponent);\n  const rendered = componentBase.render(component);\n  const localScope = scope.createChild({ this: component, refs: {} });\n  const instance = compile(rendered, component, localScope, parent);\n\n  if (scope && scope.data.refs && componentBase.ref)\n  {\n      scope.data.refs[componentBase.ref] = component;\n  }\n\n  component.node = instance;\n  component.scope = localScope;\n\n  if (componentBase.attributes)\n  {\n    for (const attr in componentBase.attributes)\n    {\n      const attrValue = componentBase.attributes[attr];\n      const attrObject = attrValue instanceof Type\n        ? { type: attrValue }\n        : attrValue;\n\n      const attrInput = attrs && attr in attrs ? attrs[attr] : attrObject.default;\n\n      if (Scope.isWatchable(attrInput))\n      {\n        let first = true;\n\n        scope.watch(attrInput, (v) =>\n        {\n          localScope.set(attr, v);\n\n          if (instance.element)\n          {\n              if (first && attrObject.initial)\n              {\n                attrObject.initial(v, component, instance.element);\n              }\n              else if (!first && attrObject.changed)\n              {\n                attrObject.changed(v, component, instance.element);\n              }\n              if (attrObject.update)\n              {\n                attrObject.update(v, component, instance.element);\n              }\n              if (!first && componentBase.updated)\n              {\n                componentBase.updated(component, instance.element);\n              }\n          }\n          \n          first = false;\n        });\n      }\n      else\n      {\n        localScope.set(attr, attrInput);\n      }\n    }\n  }\n\n  if (componentBase.state)\n  {\n    const localState = scope.eval(componentBase.state)();\n\n    if (isObject(localState)) \n    {\n      for (const stateName in localState)\n      {\n        localScope.set(stateName, localState[stateName]);\n      }\n    }\n  }\n\n  if (isObject(events) && componentBase.events) \n  {\n    for (const ev in events) \n    {\n      if (!(ev in componentBase.events))\n      {\n        continue;\n      }\n\n      const eventValue = events[ev];\n\n      if (Scope.isWatchable(eventValue)) \n      {\n        const listener = localScope.eval(eventValue);\n\n        component.on(ev, listener);\n      }\n    }\n  }\n\n  if (componentBase.created && instance.element) \n  {\n    componentBase.created(component, instance.element);\n  }\n  \n  return instance;\n};","import { NodeCompiler, NodeInstance, getSlots, changeElement, createChildNodes } from '../Node';\n\n\nexport const CompilerIf: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const placeholder = [document.createComment('if')];\n  const element: Node[] = placeholder.slice();\n  const instance: NodeInstance = { parent, component, scope, element };\n  const childScope = scope.createChild();\n  const childTemplate = getSlots(childSlots);\n\n  if (attrs && attrs.condition && childTemplate) \n  {\n    const controller = createChildNodes(childTemplate, scope, component, childScope, instance);\n\n    let visible = false;\n\n    scope.watch(attrs.condition, (newVisible) => \n    {\n      const visibleBoolean = !!newVisible;\n\n      if (visible !== visibleBoolean)\n      {\n        visible = visibleBoolean;\n        \n        const desired = visible ? controller.element : placeholder;\n\n        changeElement(instance, desired);\n\n        childScope.setEnabled(visible);\n      }\n    });\n  }\n  else\n  {\n    throw new Error(`The :if directive requires a condition attribute and a single child.`);\n  }\n\n  return instance;\n};","import { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { DEFAULT_SLOT } from '../constants';\nimport { Scope } from '../Scope';\n\n\nexport const CompilerSlot: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const element = [document.createComment('slot')];\n  const instance: NodeInstance = { parent, component, scope, element };\n\n  if (attrs)\n  {\n    const slotName = attrs.name || DEFAULT_SLOT;\n    const slotScope = scope.createChild();\n    const slots = getSlots(component.slots, slotName) || getSlots(childSlots, slotName);\n    \n    if (attrs.scope)\n    {\n      for (const scopeKey in slotScope)\n      {\n        const scopeValue = slotScope[scopeKey];\n\n        if (Scope.isWatchable(scopeValue))\n        {\n          scope.watch(scopeValue, (value) =>\n          {\n            slotScope.set(scopeKey, scopeValue);\n          });\n        }\n        else\n        {\n          slotScope.set(scopeKey, scopeValue);\n        }\n      }\n    }\n\n    if (slots)\n    {\n      const controller = createChildNodes(slots, scope, component, slotScope, instance);\n\n      instance.element = controller.element;\n    }\n  }\n\n  return instance;\n};","import { NodeCompiler, NodeInstance, NodeChildrenController, getSlots, createChildNodes, changeElement } from '../Node';\n\n\nexport const CompilerFor: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const placeholder = document.createComment('for');\n  const element = [placeholder];\n  const instance: NodeInstance = { parent, component, scope, element };\n  const itemTemplate = getSlots(childSlots);\n\n  if (attrs && attrs.items && parent)\n  {\n    const propItem = attrs.item || 'item';\n    const propIndex = attrs.index || 'index';\n    const key = scope.eval(attrs.key);\n    const map = new Map<any, NodeChildrenController>();\n\n    scope.watch(attrs.items, (items) =>\n    {\n      const newChildren: Node[] = [placeholder];\n      const keys = new Set();\n\n      for (let itemIndex = 0; itemIndex < items.length; itemIndex++)\n      {\n        const item = items[itemIndex];\n        const itemScopeData = { [propItem]: item, [propIndex]: itemIndex };\n        const itemKey = key(itemScopeData);\n        let itemController = map.get(itemKey);\n\n        if (!itemController)\n        {\n          const itemScope = scope.createChild(itemScopeData);\n\n          itemController = createChildNodes(itemTemplate, itemScope, component, itemScope, instance);\n\n          map.set(itemKey, itemController);\n        }\n        else\n        {\n          itemController.updateScopes(itemScopeData);\n        }\n\n        keys.add(itemKey);\n        newChildren.push(...itemController.element);\n      }\n\n      changeElement(instance, newChildren);\n\n      map.forEach((entryValue, entryKey) => \n      {\n        if (!keys.has(entryKey)) \n        {\n          entryValue.destroyScopes();\n\n          map.delete(entryKey);\n        }\n      });\n    });\n  }\n\n  return instance;\n};","\nexport * from './constants';\nexport * from './fns';\nexport * from './compilers';\nexport * from './compile';\nexport * from './Node';\nexport * from './Scope';\nexport * from './Component';\nexport * from './ComponentInstance';\nexport * from './ComponentRegistry';"],"sourceRoot":""}