{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/external \"expangine-runtime\"","webpack://[name]/external \"expangine-runtime-live\"","webpack://[name]/../node_modules/scrute/lib/Constants.js","webpack://[name]/../node_modules/scrute/lib/Node.js","webpack://[name]/../node_modules/scrute/lib/Dependency.js","webpack://[name]/../node_modules/scrute/lib/Watcher.js","webpack://[name]/../node_modules/scrute/lib/Link.js","webpack://[name]/../node_modules/scrute/lib/handler.js","webpack://[name]/../node_modules/scrute/lib/observe.js","webpack://[name]/../node_modules/scrute/lib/Observer.js","webpack://[name]/../node_modules/scrute/lib/watch.js","webpack://[name]/./Scope.ts","webpack://[name]/../node_modules/scrute/lib/unobserve.js","webpack://[name]/./ComponentRegistry.ts","webpack://[name]/./ComponentInstance.ts","webpack://[name]/./constants.ts","webpack://[name]/./compilers/slot.ts","webpack://[name]/./compile.ts","webpack://[name]/./Node.ts","webpack://[name]/./compilers/default.ts","webpack://[name]/./compilers/dynamic.ts","webpack://[name]/./compilers/switch.ts","webpack://[name]/./compilers/index.ts","webpack://[name]/./compilers/component.ts","webpack://[name]/./compilers/if.ts","webpack://[name]/./compilers/for.ts","webpack://[name]/./helpers.ts","webpack://[name]/./index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ARRAY_CHANGES","ARRAY_ITERATIONS","Node","this","next","prev","forEach","iterator","curr","index","toArray","out","item","push","insertAfter","last","remove","isEmpty","head","Dependency","observer","links","notify","notifyParent","deep","link","watcher","parent","destroy","liveWatchers","Watcher","expression","immediate","dirty","paused","evaluating","isWatching","update","off","result","pop","onResult","pause","resume","Link","dependency","watcherNode","dependencyNode","existing","target","prop","_reciever","val","obs","Array","copy","slice","apply","arguments","max","Math","length","deepNotified","handleArrayChange","handleWatching","handleArrayIteration","set","deleteProperty","dep","isObservable","isObserved","observe","input","_a","_b","proxy","Proxy","revocable","revoke","writable","configurable","Observer","deps","watch","expr","_c","_d","data","observed","disables","watchers","addToParent","child","children","attr","defaultValue","here","has","values","onValue","equalityCheck","cmd","eval","first","equals","node","extra","extraScope","createChild","w","enable","disable","enabled","Number","MAX_SAFE_INTEGER","unobserve","registered","dataSet","dataGet","dataHas","dataRemove","obj","x","defs","isExpression","addComponent","comp","id","ComponentRegistry","collection","register","component","attrs","scope","slots","outerScope","cache","args","attrObject","attributes","attrExpr","default","def","arg","with","getExpression","run","noop","eventName","payload","evalScope","emit","listener","updated","compile","render","changeElements","elements","slotName","options","getSlotOptions","arrayLength","maxSlotIndex","slotIndex","parseInt","undefined","const","slotInput","getCompiler","template","tag","compilers","mount","replace","rootScope","refs","instance","events","state","computed","compiled","isStyleElement","style","getSlots","isNamedSlots","isArray","parentNode","removing","Set","previousSibling","desired","current","nextSibling","delete","insertBefore","firstChild","appendChild","removeChild","splice","createChildNodes","sharedScope","scopes","document","createTextNode","isWatchable","textNode","text","textContent","childNode","childElement","setMany","modifierHandlers","prevent","el","ev","preventDefault","stop","stopPropagation","self","hasModifier","modifiers","modifier","indexOf","exists","applyAttribute","e","hasAttribute","removeAttribute","setAttribute","convertToString","forStyle","map","y","join","converted","String","toLowerCase","CompilerSwitch","childSlots","directiveName","substring","placeholder","createComment","childScope","cases","Error","switch","isEqual","caseName","case","than","lastVisibleSlot","lastController","nextTemplate","setEnabled","hideElements","hide","display","nextController","showElements","show","element","createElement","attrValue","v","eventParts","split","shift","eventValue","listenerOptions","once","passive","capture","handler","addEventListener","nativeEvent","eventObject","childs","childController","lastScope","tagValue","dynamicInstance","parentComponent","componentBase","localScope","addRef","ref","type","callable","attrInput","initial","changed","stateName","stateValue","computedName","computedValue","on","created","componentSlots","slotOverride","slotScope","slotOptions","slotIndexName","arrayIndexAlias","scopeKey","scopeValue","controller","itemTemplate","items","propItem","propIndex","propKey","Map","newChildren","keys","callback","entries","iterateCollection","itemIndex","itemScopeData","itemKey","itemController","updateScopes","itemScope","add","createIf","condition","truthy","createIfs","createIfElse","falsy","otherwise","reduce","tmpl","createShow","createHide","not","createSwitch","defaultCase","createComponent","createFor","createSlot"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,qBAAsBA,QAAQ,2BACtC,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,oBAAqB,0BAA2BJ,GAC9B,iBAAZC,QACdA,QAAQ,gBAAkBD,EAAQG,QAAQ,qBAAsBA,QAAQ,2BAExEJ,EAAK,gBAAkBC,EAAQD,EAAK,qBAAsBA,EAAK,2BARjE,CASGO,QAAQ,SAASC,EAAgCC,GACpD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUV,QAGnC,IAAIC,EAASO,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHZ,QAAS,IAUV,OANAa,EAAQH,GAAUI,KAAKb,EAAOD,QAASC,EAAQA,EAAOD,QAASS,GAG/DR,EAAOW,GAAI,EAGJX,EAAOD,QA0Df,OArDAS,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASjB,EAASkB,EAAMC,GAC3CV,EAAoBW,EAAEpB,EAASkB,IAClCG,OAAOC,eAAetB,EAASkB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASzB,GACX,oBAAX0B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAetB,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAetB,EAAS,aAAc,CAAE4B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASnC,GAChC,IAAIkB,EAASlB,GAAUA,EAAO8B,WAC7B,WAAwB,OAAO9B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAQ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrDzC,EAAOD,QAAUM,G,cCAjBL,EAAOD,QAAUO,G,sDCQNoC,EAAgB,CACvB,IAAO,EACP,KAAQ,EACR,MAAS,EACT,QAAW,EACX,QAAW,EACX,OAAU,EACV,KAAQ,GAODC,EAAmB,CAC1B,OAAU,EACV,MAAS,EACT,KAAQ,EACR,OAAU,EACV,KAAQ,EACR,UAAa,EACb,QAAW,EACX,SAAY,EACZ,QAAW,EACX,KAAQ,EACR,YAAe,EACf,IAAO,EACP,OAAU,EACV,YAAe,EACf,MAAS,EACT,KAAQ,GCjCRC,EAAsB,WAMtB,SAASA,EAAKjB,GACVkB,KAAKlB,MAAQA,EACbkB,KAAKC,KAAOD,KAAKE,KAAOF,KAuE5B,OA7DAD,EAAKN,UAAUU,QAAU,SAAUC,GAG/B,IAFA,IAAIC,EAAOL,KAAKC,KACZK,EAAQ,EACLD,IAASL,MAAM,CAClB,IAAIC,EAAOI,EAAKJ,KAChBG,EAASC,EAAKvB,MAAOuB,EAAMC,GAC3BD,EAAOJ,EACPK,IAEJ,OAAOA,GAKXP,EAAKN,UAAUc,QAAU,WACrB,IAAIC,EAAM,GAEV,OADAR,KAAKG,SAAQ,SAAUM,GAAQ,OAAOD,EAAIE,KAAKD,MACxCD,GAOXT,EAAKN,UAAUkB,YAAc,SAAUT,GACnCF,KAAKC,KAAOC,EAAKD,KACjBD,KAAKE,KAAOA,EACZF,KAAKE,KAAKD,KAAOD,KAAKC,KAAKC,KAAOF,MAStCD,EAAKN,UAAUiB,KAAO,SAAUE,GAC5BA,EAAKD,YAAYX,KAAKE,OAK1BH,EAAKN,UAAUoB,OAAS,WACfb,KAAKc,YACNd,KAAKC,KAAKC,KAAOF,KAAKE,KACtBF,KAAKE,KAAKD,KAAOD,KAAKC,KACtBD,KAAKE,KAAOF,KAAKC,KAAOD,OAMhCD,EAAKN,UAAUqB,QAAU,WACrB,OAAOd,KAAKC,OAASD,MAKzBD,EAAKgB,KAAO,WACR,OAAO,IAAIhB,EAAK,OAEbA,EA/Ec,GCDrB,EAA4B,WAM5B,SAASiB,EAAWC,GAChBjB,KAAKiB,SAAWA,EAChBjB,KAAKkB,MAAQnB,EAAKgB,OA8BtB,OAnBAC,EAAWvB,UAAU0B,OAAS,SAAUC,QACf,IAAjBA,IAA2BA,GAAe,GAC9C,IAAIC,GAAO,EASX,OAPArB,KAAKkB,MAAMX,UAAUJ,SAAQ,SAAUmB,GACnCA,EAAKC,QAAQJ,SACbE,EAAOA,GAAQC,EAAKC,QAAQF,QAE5BD,GAAgBC,GAAQrB,KAAKiB,SAASO,QACtCxB,KAAKiB,SAASO,OAAOL,OAAOC,GAEzBC,GAKXL,EAAWvB,UAAUgC,QAAU,WAC3BzB,KAAKkB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOA,EAAKT,aAE9CG,EAtCoB,GCApBU,EAAe,GAMtB,EAAyB,WAKzB,SAASC,EAAQC,EAAYC,EAAWR,QAClB,IAAdQ,IAAwBA,GAAY,QAC3B,IAATR,IAAmBA,GAAO,GAC9BrB,KAAK4B,WAAaA,EAClB5B,KAAK6B,UAAYA,EACjB7B,KAAKqB,KAAOA,EACZrB,KAAK8B,OAAQ,EACb9B,KAAK+B,QAAS,EACd/B,KAAKgC,YAAa,EAClBhC,KAAKkB,MAAQnB,EAAKgB,OAqEtB,OA/DAY,EAAQlC,UAAUwC,WAAa,WAC3B,OAAQjC,KAAKkB,MAAMJ,WAKvBa,EAAQlC,UAAU0B,OAAS,WACnBnB,KAAKgC,aAGThC,KAAK8B,OAAQ,EACT9B,KAAK6B,WACL7B,KAAKkC,WAMbP,EAAQlC,UAAUyC,OAAS,WACvBlC,KAAKgC,YAAa,EAClBhC,KAAKmC,MACLT,EAAahB,KAAKV,MAClB,IACIA,KAAKoC,OAASpC,KAAK4B,aAEvB,QAGI,GAFAF,EAAaW,MACbrC,KAAK8B,OAAQ,EACT9B,KAAKsC,SACL,IACItC,KAAKsC,WAET,QACItC,KAAKgC,YAAa,EAG1BhC,KAAKgC,YAAa,IAM1BL,EAAQlC,UAAU0C,IAAM,WACpBnC,KAAKkB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOA,EAAKT,aAKrDc,EAAQlC,UAAU8C,MAAQ,WACjBvC,KAAK+B,SACN/B,KAAKmC,MACLnC,KAAK+B,QAAS,IAMtBJ,EAAQlC,UAAU+C,OAAS,WACnBxC,KAAK+B,SACL/B,KAAKkC,SACLlC,KAAK+B,QAAS,IAGfJ,EAnFiB,GCJxB,EAAsB,WAItB,SAASc,EAAKlB,EAASmB,GACnB1C,KAAKuB,QAAUA,EACfvB,KAAK0C,WAAaA,EAClB1C,KAAK2C,YAAc,IAAI5C,EAAKC,MAC5BA,KAAK4C,eAAiB,IAAI7C,EAAKC,MAyBnC,OApBAyC,EAAKhD,UAAUoB,OAAS,WACpBb,KAAK2C,YAAY9B,SACjBb,KAAK4C,eAAe/B,UAQxB4B,EAAKtD,OAAS,SAAUoC,EAASmB,GAC7B,IAAIG,EAAW,KAOf,OANAH,EAAWxB,MAAMf,SAAQ,SAAUmB,GAAQ,OAAOuB,EAAYvB,EAAKC,UAAYA,EAAUD,EAAOuB,KAC3FA,IACDA,EAAW,IAAIJ,EAAKlB,EAASmB,GAC7BA,EAAWxB,MAAMR,KAAKmC,EAASD,gBAC/BrB,EAAQL,MAAMR,KAAKmC,EAASF,cAEzBE,GAEJJ,EAjCc,GCCd,EAAU,CAKjB/D,IAAK,SAAUoE,EAAQC,EAAMC,GACzB,IAAIC,EAAMH,EAAOC,GACjB,GLXc,SKWVA,EACA,OAAOE,EAEX,IAAIC,EAAMJ,EAAe,KACzB,GAAmB,mBAARG,EAAoB,CAC3B,GAAIH,aAAkBK,MAAO,CACzB,GAAIJ,KAAQlD,EACR,OA8DpB,SAA2BiD,EAAQG,EAAKC,GACpC,OAAO,WAKH,IAJA,IAAIE,EAAON,EAAOO,QACdjB,EAASa,EAAIK,MAAMR,EAAQS,WAC3BC,EAAMC,KAAKD,IAAIJ,EAAKM,OAAQZ,EAAOY,QACnCC,GAAe,EACV9F,EAAI,EAAGA,EAAI2F,EAAK3F,IACjBuF,EAAKvF,KAAOiF,EAAOjF,KACnB8F,EAAeA,GAAgBT,EAAI/B,OAAOtD,IAE1CA,GAAKiF,EAAOY,QACZR,EAAIrC,OAAOhD,GASnB,OANIiF,EAAOY,SAAWN,EAAKM,SACvBC,EAAeA,GAAgBT,EAAI/B,OAAO,WAE1CwC,GAAgBT,EAAI1B,QACpB0B,EAAI1B,OAAOL,QAAO,GAEfiB,GAlFYwB,CAAkBd,EAAQG,EAAKC,GAE1C,GAAIH,KAAQjD,EACR,OA6CpB,SAA8BgD,EAAQG,EAAKC,GACvC,OAAO,WAEH,IADA,IAAIQ,EAASZ,EAAOY,OACX7F,EAAI,EAAGA,EAAI6F,EAAQ7F,IACxBgG,EAAef,EAAQjF,EAAGiF,EAAOjF,GAAIqF,GAGzC,OADAW,EAAef,EAAQ,SAAUA,EAAOY,OAAQR,GACzCD,EAAIK,MAAMR,EAAQS,YApDNO,CAAqBhB,EAAQG,EAAKC,GAGjD,OAAOD,EAEX,OAAOY,EAAef,EAAQC,EAAME,EAAKC,IAK7Ca,IAAK,SAAUjB,EAAQC,EAAMjE,EAAOkE,GAC5BlE,IAAUgE,EAAOC,KACjBD,EAAOC,GAAQjE,EACLgE,EAAe,KACrB3B,OAAO4B,GAAM,IAErB,OAAO,GAMXiB,eAAgB,SAAUlB,EAAQC,GAG9B,OAFUD,EAAe,KACrBjC,OAAOkC,IACJ,IAQf,SAASc,EAAef,EAAQC,EAAME,EAAKC,GACvC,IAAIe,EAAMf,EAAIe,IAAIlB,GAKlB,OAJArB,EAAavB,SAAQ,SAAUoB,GAAW,OAAO,EAAKpC,OAAOoC,EAAS0C,MAClEC,EAAajB,KAASkB,EAAWlB,KACjCH,EAAOC,GAAQE,EAAMmB,EAAQnB,EAAK,CAAEzB,OAAQyC,KAEzChB,ECnDJ,SAASmB,EAAQC,EAAOC,GAC3B,IAAIC,QAAa,IAAPD,EAAgB,GAAKA,GAAI9C,OAAQA,OAAgB,IAAP+C,EAAgB,KAAOA,EAC3E,GAAIL,EAAaG,KACRA,EAAc,KAAG,CAClB,IAAIG,EAAQC,MAAMC,UAAUL,EAAO,GACnCA,EAAQG,EAAMA,MACdjG,OAAOC,eAAe6F,ENfZ,OMe6B,CACnCvF,MAAO,IAAI,EAAS0F,EAAMG,OAAQnD,GAClCoD,UAAU,EACVC,cAAc,EACdpG,YAAY,IAIxB,OAAO4F,EAOJ,SAASH,EAAaG,GACzB,QAA2B,iBAAVA,GAAgC,OAAVA,GAOpC,SAASF,EAAWE,GACvB,QAA2B,iBAAVA,GAAgC,OAAVA,IAAkBA,EAAc,MClC3E,IAAI,EAA0B,WAM1B,SAASS,EAASH,EAAQnD,QACP,IAAXA,IAAqBA,EAAS,MAClCxB,KAAK2E,OAASA,EACd3E,KAAKwB,OAASA,EACdxB,KAAK+E,KAAOxG,OAAOY,OAAO,MA4E9B,OApEA2F,EAASrF,UAAUwE,IAAM,SAAUlB,GAC/B,IAAIkB,EAAMjE,KAAK+E,KAAKhC,GAIpB,OAHKkB,IACDjE,KAAK+E,KAAKhC,GAAQkB,EAAM,IAAI,EAAWjE,OAEpCiE,GAYXa,EAASrF,UAAU0B,OAAS,SAAU4B,EAAM3B,QACnB,IAAjBA,IAA2BA,GAAe,GAC9C,IAAI2D,EAAO/E,KAAK+E,KAChB,OAAIhC,KAAQgC,EACDA,EAAKhC,GAAM5B,OAAOC,IAEpBA,GAAgBpB,KAAKwB,QAC1BxB,KAAKwB,OAAOL,OAAOC,IAEhB,IASX0D,EAASrF,UAAUoB,OAAS,SAAUkC,GAClC,IAAIgC,EAAO/E,KAAK+E,KACZhC,KAAQgC,IACRA,EAAKhC,GAAMtB,iBACJsD,EAAKhC,KAUpB+B,EAASrF,UAAUgC,QAAU,SAAUqB,EAAQzB,EAAMsD,QACpC,IAATtD,IAAmBA,GAAO,QACf,IAAXsD,IAAqBA,GAAS,GAClC,IAAII,EAAO/E,KAAK+E,KAChB,IAAK,IAAIhC,KAAQgC,EAGb,GAFAA,EAAKhC,GAAMtB,iBACJsD,EAAKhC,GACR1B,EAAM,CACN,IAAIvC,EAAQgE,EAAOC,GACnB,GAAIoB,EAAWrF,GACDA,EAAc,KACpB2C,QAAQ3C,EAAOuC,EAAMsD,GAIjCA,GACA3E,KAAK2E,UAGNG,EAtFkB,GCMtB,SAASE,EAAMC,EAAMX,GACxB,IAAIC,OAAY,IAAPD,EAAgB,GAAKA,EAAIY,EAAKX,EAAG1C,UAAWA,OAAmB,IAAPqD,GAAuBA,EAAIC,EAAKZ,EAAGlD,KAChGE,EAAU,IAAI,EAAQ0D,EAAMpD,OADwF,IAAPsD,GAAwBA,GAGzI,OADA5D,EAAQW,SACDX,ECZJ,MAAM,EAUX,YAAmBC,EAAuB,KAAM4D,EAAU7G,OAAOY,OAAO,OAEtEa,KAAKwB,OAASA,EACdxB,KAAKqF,SAAWjB,EAAQgB,GACxBpF,KAAKsF,SAAW,EAChBtF,KAAKsB,KAAO,IAAI,EAAWtB,MAC3BA,KAAKuF,SAAW,EAAWxE,OAGtB,YAAYqE,EAAY,GAAII,GAAuB,GAExD,MAAMC,EAAQ,IAAI,EAAMzF,KAAMoF,GAY9B,OAVII,IAEGxF,KAAK0F,WAER1F,KAAK0F,SAAW,EAAW3E,QAG7Bf,KAAK0F,SAAShF,KAAK+E,EAAMnE,OAGpBmE,EAGF,IAAuBE,EAASC,EAAqBC,GAAgB,GAE1E,OAAOF,KAAQ3F,KAAKqF,SAChBrF,KAAKqF,SAASM,GACd3F,KAAKwB,SAAWqE,EACd7F,KAAKwB,OAAO9C,IAAIiH,EAAMC,GACtBA,EAGD,IAAID,EAAgCE,GAAgB,GAEzD,OAAOF,KAAQ3F,KAAKqF,aAEhBrF,KAAKwB,QAAWqE,IACd7F,KAAKwB,OAAOsE,IAAIH,GAIjB,IAAuBA,EAAS7G,EAAa+G,GAAgB,GAElE,GAAIF,KAAQ3F,KAAKqF,UAAYQ,EAE3B7F,KAAKqF,SAASM,GAAQ7G,MAEnB,KAAIkB,KAAKwB,OASZ,OAAO,EAPFxB,KAAKwB,OAAOuC,IAAI4B,EAAM7G,KAEzBkB,KAAKqF,SAASM,GAAQ7G,GAQ1B,OAAO,EAGF,OAA0B6G,GAE3BA,KAAQ3F,KAAKqF,gBAERrF,KAAKqF,SAASM,GAEd3F,KAAKwB,QAEZxB,KAAKwB,OAAOX,OAAO8E,GAIhB,QAAQI,GAEb,IAAK,MAAMhD,KAAQgD,EAEjB/F,KAAK+D,IAAIhB,EAAMgD,EAAOhD,IAInB,MAAMkC,EAAWe,EAA+BnE,GAAqB,EAAMoE,GAAyB,GAEzG,MAAMC,EAAM,cAAYC,KAAKlB,GAC7B,IACIrE,EADAwF,GAAiB,EAGrB,MAAM7E,EAAUyD,EAAM,KACpB,MAAM5C,EAAS8D,EAAIlG,OAEf6B,GAAcuE,IACZA,GAAWH,GAAkB,YAAUI,OAAOzF,EAAMwB,IACtD4D,EAAQ5D,GAIZxB,EAAOqF,EAAgB,YAAU7C,KAAKhB,GAAUA,EAChDgE,GAAQ,IAGJE,EAAO,IAAI,EAAW/E,GAI5B,OAFAvB,KAAKuF,SAAS7E,KAAK4F,GAEZ,KACL/E,EAAQY,MACRmE,EAAKzF,UAIF,KAAKoE,GAEV,MAAMiB,EAAM,cAAYC,KAAKlB,GAE7B,OAAQsB,IAEN,GAAIA,EACJ,CACE,MAAMC,EAAaxG,KAAKyG,YAAYF,GAC9BnE,EAAS8D,EAAIM,GAInB,OAFAA,EAAW/E,UAEJW,EAIP,OAAO8D,EAAIlG,OAKV,SAEDA,KAAKsF,SAAW,IAElBtF,KAAKsF,WAEiB,IAAlBtF,KAAKsF,UAEPtF,KAAKuF,SAASpF,QAASuG,GAAMA,EAAElE,UAG7BxC,KAAK0F,UAEP1F,KAAK0F,SAASvF,QAASjC,GAAMA,EAAEyI,WAK9B,UAEiB,IAAlB3G,KAAKsF,UAEPtF,KAAKuF,SAASpF,QAASuG,GAAMA,EAAEnE,SAG7BvC,KAAK0F,UAEP1F,KAAK0F,SAASvF,QAASjC,GAAMA,EAAE0I,WAGjC5G,KAAKsF,WAGA,WAAWuB,GAEhBA,EAAU7G,KAAK2G,SAAW3G,KAAK4G,UAG1B,UAEL5G,KAAKsB,KAAKT,SACVb,KAAKsF,SAAWwB,OAAOC,iBACvB/G,KAAKuF,SAASpF,QAASuG,GAAMA,EAAEvE,OAE3BnC,KAAK0F,UAEP1F,KAAK0F,SAASvF,QAASjC,GAAMA,EAAEuD,WC3L9B,SAAmB4C,EAAOhD,EAAMI,GAGnC,QAFa,IAATJ,IAAmBA,GAAO,QACd,IAAZI,IAAsBA,GAAU,GAChC0C,EAAWE,GAAQ,CACnB,IAAInB,EAAMmB,EAAc,YACjBA,EAAc,KACrBnB,EAAIzB,QAAQ4C,EAAOhD,EAAMI,IDwL7BuF,CAAUhH,KAAKqF,UAKV,kBAEL,IAAKrF,KAAKiH,WACV,CACE,MAAM,QAAEC,EAAO,QAAEC,EAAO,QAAEC,EAAO,WAAEC,GAAe,cAElD,cAAYF,QAAU,CAACG,EAAKvE,IAASuE,aAAe,EAAQA,EAAI5I,IAAIqE,GAAQoE,EAAQG,EAAKvE,GACzF,cAAYmE,QAAU,CAACI,EAAKvE,EAAMjE,IAAUwI,aAAe,EAAQA,EAAIvD,IAAIhB,EAAMjE,GAASoI,EAAQI,EAAKvE,EAAMjE,GAC7G,cAAYsI,QAAU,CAACE,EAAKvE,IAASuE,aAAe,EAAQA,EAAIxB,IAAI/C,GAAQqE,EAAQE,EAAKvE,GACzF,cAAYsE,WAAa,CAACC,EAAKvE,IAASuE,aAAe,EAAQA,EAAIzG,OAAOkC,GAAQsE,EAAWC,EAAKvE,GAElG/C,KAAKiH,YAAa,GAIf,mBAAmBM,GAExB,OAAO,cAAYC,KAAKC,aAAaF,IE7NlC,SAASG,EAAmFC,EAAgCC,GAIjI,OAFAC,EAAkBD,GAAM,GAAGD,EAAKG,cAAcH,EAAKvJ,QAAUuJ,EAEtDA,EFsMQ,EAAAV,YAAsB,EAyBvC,EAAMc,WE5NC,MAAMF,EAAwEtJ,OAAOY,OAAO,MCE5F,MAAM,EAWX,YAAmB6I,EAAqCC,EAAkDC,EAAcC,EAAgC3G,EAA+B4G,GAErLpI,KAAKgI,UAAYA,EACjBhI,KAAKiI,MAAQA,EACbjI,KAAKkI,MAAQA,EACblI,KAAKoI,WAAaA,GAAcF,EAChClI,KAAKmI,MAAQA,EACbnI,KAAKwB,OAASA,EACdxB,KAAKqI,MAAQ9J,OAAOY,OAAO,MAGtB,KAAwBwG,EAAS2C,G,QAEtC,MAAMC,EAAqF,QAAvE,EAAAvI,KAAKgI,UAAwDQ,kBAAU,eAAG7C,GAExF8C,EADYzI,KAAKiI,MAAMtC,KACgE,QAAnE,EAAK4C,SAA8D,eAAEG,SAE/F,GAAID,EACJ,CACE,MAAME,EAAM,QAAMtL,SAElB,IAAK,MAAMuL,KAAON,EAEhBK,EAAIE,KAAKD,EAAK,OAAKE,cAAcR,EAAKM,KAKxC,OAFAD,EAAII,IAAI,OAAKD,cAAcL,IAEpBE,EAGT,OAAO,QAAMK,OAGR,QAA2BC,EAAcC,EAAeC,EAAmBnJ,KAAKkI,OAErFlI,KAAKkI,MAAM7C,SAAS+D,KAAKH,GAAaE,EAAUhD,KAAK+C,EAAfC,GAGjC,GAAsBF,EAAcI,GAEzC,OAAOrJ,KAAKkI,MAAMlD,MAChB,QAAMtG,IAAI,OAAQuK,GAClBI,GACA,GAIG,SAEDrJ,KAAKgI,UAAUsB,SAAWtJ,KAAKsG,MAEjCtG,KAAKgI,UAAUsB,QAAQtJ,MAIpB,SAELA,KAAKqI,MAAQ9J,OAAOY,OAAO,MAE3B,MACMmH,EAAOiD,EADIvJ,KAAKgI,UAAUwB,OAAOxJ,MACRA,KAAMA,KAAKkI,OAE1CuB,EAAezJ,KAAKsG,KAAKoD,SAAUpD,EAAKoD,UAExC1J,KAAKsG,KAAOA,EAGP,UAELtG,KAAKkI,MAAMzG,UAGN,mBAAmBkI,EC9FA,WDgGxB,MAAMC,EAAU5J,KAAK6J,eAAeF,GAEpC,GAAIC,GAAWA,EAAQE,YAErB,OAAO,OAAKhB,cAAcc,EAAQE,aAGpC,GAAI9J,KAAKmI,OAASnI,KAAKmI,MAAMwB,IAAa,mBAAS3J,KAAKmI,MAAMwB,IAC9D,CACE,MAAMxB,EAAQnI,KAAKmI,MAAMwB,GACzB,IAAII,EAEJ,IAAK,MAAMC,KAAa7B,EACxB,CACE,MAAMtK,EAAIoM,SAASD,GAEf,mBAASnM,UAAwBqM,IAAjBH,GAA8BlM,EAAIkM,KAEpDA,EAAelM,GAInB,QAAqBqM,IAAjBH,EAEF,OAAO,QAAMI,MAAMJ,EAAe,GAItC,OAAO,QAAMI,MAAM,GAGd,eAAeR,GAEpB,MAAMzL,EAAI8B,KAAKgI,UAEf,GAAI9J,EAAEiK,MACN,CACE,MAAMiC,EAAYlM,EAAEiK,MAAMwB,GAE1B,OE9D0BpC,EF8DH6C,EE5DpB,mBAAS7C,IAAMA,EAAEW,iBAAiB,OF6DjCkC,EACA,CAAElC,MAAOkC,GEhEZ,IAAyB7C,EFmE5B,OAAO,GGpIJ,SAAS8C,EAAYC,GAE1B,MAAOC,GAAOD,EACRlL,EAAM,mBAASmL,GACjBA,KAAOC,EACLD,EACAA,KAAO1C,EFXmB,aAFF,IACA,WEiB9B,OAAO2C,EAAUpL,GAGZ,SAASmK,EAAQe,EAAwBtC,EAAiCE,EAAc1G,GAE7F,OAAO6I,EAAYC,EAAZD,CAAsBC,EAAUtC,EAAWE,EAAO1G,GAGpD,SAASiJ,EAASrF,EAASkF,EAAwBI,GAExD,MAAMC,EAAY,IAAI,EAAS,KAAM,OAAF,wBAAOvF,GAAI,CAAEwF,KAAM,MAEhDC,EAAW,IAAI,EAA2C,CAC9D/C,WAAY,YACZ1J,KAAM,UACNoK,WAAY,GACZsC,OAAQ,GACR3C,MAAO,GACP4C,MAAO,GACPC,SAAU,GACVxB,OAAQ,IAAMc,GACb,GAAIK,GAEDM,EAAW1B,EAAQe,EAAUO,EAAUF,GAS7C,OAPID,GAEFjB,EAAe,CAACiB,GAAUO,EAASvB,UAGrCmB,EAASvE,KAAO2E,EAETJ,ECjBF,SAASK,EAAe3D,GAE7B,QAASA,GAAK,mBAASA,EAAE4D,OAGpB,SAASC,EAASjD,EAA2B/J,EHvCxB,UGuCqD4L,EAAoB,GAEnG,OAAQ7B,EAEJ,kBAAQA,GACNA,EACA,mBAASA,IAAU,kBAAQA,EAAM/J,IAC/B+J,EAAM/J,GACN,mBAAS+J,IAAU,mBAASA,EAAM/J,KAAU,kBAAQ+J,EAAM/J,GAAM4L,IAC9D7B,EAAM/J,GAAM4L,GACZ,GAPN,GAWC,SAASqB,EAAavM,GAE3B,MAAwB,iBAAVA,IAAuBqE,MAAMmI,QAAQxM,GAG9C,SAAS2K,EAAe3G,EAAgB4G,GAE7C,GAAsB,IAAlB5G,EAAOY,OAETZ,EAAOpC,QAAQgJ,OAGjB,CACE,MAAMlI,EAASsB,EAAO,GAAGyI,WAEzB,GAAI/J,EACJ,CACE,MAAMgK,EAAsB,IAAIC,IAAI3I,GACpC,IAAI5C,EAAa4C,EAAO,GAAG4I,gBAE3B,IAAK,IAAI7N,EAAI,EAAGA,EAAI6L,EAAShG,OAAQ7F,IACrC,CACE,MAAM8N,EAAUjC,EAAS7L,GACnB+N,EAAU1L,EACZA,EAAK2L,YACL/I,EAAOjF,GAEX2N,EAASM,OAAOH,GAEZC,IAAYD,IAEVC,EAEFpK,EAAOuK,aAAaJ,EAASC,IAErB1L,GAAQsB,EAAOwK,WAEvBxK,EAAOuK,aAAaJ,EAASnK,EAAOwK,YAIpCxK,EAAOyK,YAAYN,IAIvBzL,EAAOyL,EAGT,IAAK,MAAM9K,KAAU2K,EAEnBhK,EAAO0K,YAAYrL,GAIvBiC,EAAOqJ,OAAO,EAAGrJ,EAAOY,UAAWgG,IAWhC,SAAS0C,EAAiB1G,EAA+BwC,EAAcF,EAAiC6C,EAAwBwB,GAAuB,GAE5J,MAAM3C,EAAmB,GACnB4C,EAAkB,GAExB,IAAK,MAAM7G,KAASC,EAElB,GAAI,mBAASD,GAEXiE,EAAShJ,KAAK6L,SAASC,eAAe/G,SAEnC,GAAI,EAAMgH,YAAYhH,GAC3B,CACE,MAAMiH,EAAWH,SAASC,eAAe,IAEzCtE,EAAMlD,MAAMS,EAAQkH,IAElBD,EAASE,YAAcD,IAGzBjD,EAAShJ,KAAKgM,OAGhB,CACE,MAAMG,EAAYtD,EAAQ9D,EAAOuC,EAAWE,EAAO2C,GAEnD,IAAK,MAAMiC,KAAgBD,EAAUnD,SAEnCA,EAAShJ,KAAKoM,GAGZD,EAAU3E,QAAUA,GAEtBoE,EAAO5L,KAAKmM,EAAU3E,OAGnB2C,EAASnF,SAMZmF,EAASnF,SAAShF,KAAKmM,GAJvBhC,EAASnF,SAAW,CAACmH,GAS3B,MAAO,CACLnD,WACA,aAAa3D,GAEXmC,EAAM6E,QAAQhH,GAEd,IAAK,MAAMnG,KAAK0M,EAEd1M,EAAEmN,QAAQhH,IAGd,UAEOsG,GAEHnE,EAAMzG,UAGR,IAAK,MAAM7B,KAAK0M,EAEd1M,EAAE6B,YC7KH,MAmGDuL,EAA4E,CAChFC,QAAO,CAAEC,EAAiBC,KACpBA,EAAGC,gBACLD,EAAGC,kBAGE,GAETC,KAAI,CAAEH,EAAiBC,KACjBA,EAAGG,iBACLH,EAAGG,mBAGE,GAETC,KAAI,CAAEL,EAAiBC,IACdA,EAAGrK,SAAWoK,GAIzB,SAASM,EAAYC,EAAqBC,GAExC,MAAM7P,EAAI4P,EAAUE,QAAQD,GACtBE,EAAS/P,GAAK,EAOpB,OALI+P,GAEFH,EAAUtB,OAAOtO,EAAG,GAGf+P,EAGT,SAASC,EAAeC,EAAgBnI,EAAc7G,GAEtC,KAAVA,SAAgBA,EAEdgP,EAAEC,aAAapI,IAEjBmI,EAAEE,gBAAgBrI,GAKpBmI,EAAEG,aAAatI,EAInB,SAASuI,EAAgB3G,EAAQ4G,GAAoB,GAEnD,GAAI,kBAAQ5G,GAEV,OAAOA,EAAE6G,IAAKC,GAAMH,EAAgBG,IAAIC,KAAKH,EAAW,KAAO,KAE5D,GAAI,mBAAS5G,GAClB,CACE,MAAMgH,EAAY,GAElB,IAAK,MAAMxL,KAAQwE,GAEbA,EAAExE,IAAUoL,GAAwB,IAAZ5G,EAAExE,KAE5BwL,EAAU7N,KAAKyN,EACXpL,EAAO,KAAOmL,EAAgB3G,EAAExE,IAChCA,GAKR,OAAOwL,EAAUD,KAAKH,EAAW,KAAO,KAG1C,OAAOK,OAAOjH,GA5BS2G,CAAgBpP,EAA8B,UAAvB6G,EAAK8I,gBCvJ9C,MCEMC,EAA+B,CAACpE,EAAUtC,EAAWE,EAAO1G,KAEvE,MAAO+I,EAAKtC,EAAO,CAAE0G,GAAcrE,EAC7BsE,EAAiBrE,EAAesE,UAAU,GAC1CC,EAAc,CAACvC,SAASwC,cAAcH,IACtClF,EAAmBoF,EAAYzL,QAC/BwH,EAAyB,CAAErJ,SAAQwG,YAAWE,QAAOwB,YACrDsF,EAAa9G,EAAMzB,cAEzB,KAAIwB,GAASA,EAAMgH,OAAShH,EAAMnJ,OA+GhC,MAAM,IAAIoQ,MAAM,OAAO3E,qDA9GzB,CACE,MAAMvL,EAAmBiJ,EAAMjJ,MAAQ,SACjCF,EAAQ,OAAKgK,cAAcb,EAAMnJ,OAEjCmG,EAAO,QAAMkK,OAAOrQ,EAAOmJ,EAAMmH,SAAW,SAAOA,SACzD,IAAK,MAAMC,KAAYpH,EAAMgH,MAC3BhK,EAAKqK,KAAKrH,EAAMgH,MAAMI,IAAWE,KAAKF,GAIxC,IAAIG,EACAC,EAHJxK,EAAKyD,QNxBmB,WM6BxBR,EAAMlD,MAAMC,EAAO0E,IAEjB,MAAM+F,EAAetE,EAASuD,EAAYhF,GAE1C,GAA4B,IAAxB+F,EAAahM,OAIf,OAFAsL,EAAWW,YAAW,GAEd3Q,GAEN,IAAK,SACHyK,EAAeoB,EAASnB,SAAUoF,GAClC,MAEF,IAAK,UACCW,IAEFA,EAAehO,UACfgO,OAAiBvF,GAGnBT,EAAeoB,EAASnB,SAAUoF,GAClC,MAEF,IAAK,OACH,GAAIW,EACJ,CACE,MAAMG,EAAe/E,EAASnB,SAASrG,QAEvC,IAAK,IAAIxF,EAAI,EAAGA,EAAI+R,EAAalM,OAAQ7F,IACzC,CACE,MAAMgS,EAAOD,EAAa/R,GAEtBqN,EAAe2E,GAEjBA,EAAK1E,MAAM2E,QAAU,OAIrBF,EAAa/R,GAAK0O,SAASwC,cAAc,IAI7CtF,EAAeoB,EAASnB,SAAUkG,QAM1C,CACE,GAAIjG,IAAa6F,GAA4B,YAATxQ,EACpC,CACMyQ,IAEFA,EAAehO,UACfgO,OAAiBvF,GAGnB,MAAM6F,EAAiB3D,EAAiBsD,EAAcV,EAAYhH,EAAW6C,GAAU,GAEvFpB,EAAeoB,EAASnB,SAAUqG,EAAerG,UAEjD+F,EAAiBM,EACjBP,EAAkB7F,OAEf,GAAa,WAAT3K,EAEPyK,EAAeoB,EAASnB,SAAU+F,EAAe/F,cAGnD,CACE,MAAMsG,EAAenF,EAASnB,SAASrG,QAEvC,IAAK,IAAIxF,EAAI,EAAGA,EAAImS,EAAatM,OAAQ7F,IACzC,CACE,MAAMoS,EAAOD,EAAanS,GAEtBqN,EAAe+E,GAEjBA,EAAK9E,MAAM2E,QAAU,GAIrBE,EAAanS,GAAK4R,EAAe/F,SAAS7L,GAI9C4L,EAAeoB,EAASnB,SAAUsG,GAGpChB,EAAWW,YAAW,MAGvB,GAAM,GAOX,OAAO9E,GCtHF,MAAML,EAA0C,CACrD,IHA2C,CAACF,EAAUtC,EAAWE,EAAO1G,KAExE,MAAO+I,EAAKtC,EAAO6C,EAAQ6D,GAAcrE,EACnC4F,EAAU3D,SAAS4D,cAAc5F,GACjCM,EAAyB,CAAEnB,SAAU,CAACwG,GAAUlI,YAAWE,QAAO1G,UAExE,GAAI,mBAASyG,GAEX,IAAK,MAAMtC,KAAQsC,EACnB,CACE,MAAMmI,EAAYnI,EAAMtC,GAEpB,EAAM8G,YAAY2D,GAEpBlI,EAAMlD,MAAMoL,EAAYC,IAEtBxC,EAAeqC,EAASvK,EAAM0K,KAKhCxC,EAAeqC,EAASvK,EAAMyK,GAKpC,GAAI,mBAAStF,GAEX,IAAK,MAAMqC,KAAMrC,EACjB,CACE,MAAMwF,EAAanD,EAAGoD,MAAM,KACtBtH,EAAYqH,EAAWE,QACvBC,EAAa3F,EAAO7B,GAEpByH,EAA2C,CAC/CC,KAAUnD,EAAY8C,EAAY,QAClCM,QAAUpD,EAAY8C,EAAY,WAClCO,QAAUrD,EAAY8C,EAAY,YAG9BQ,EAAU,qBAAWL,GACvBA,EACAvI,EAAM/B,KAAKsK,GAEfP,EAAQa,iBAAiB9H,EAAY+H,IAEnC,IAAK,MAAMtD,KAAY4C,EAErB,GAAI5C,KAAYV,IAETA,EAAiBU,GAAUwC,EAASc,GAEvC,OAKN,MAAMC,EAAkC,CACtCD,cACA9I,QACAmF,MAAM,EACNJ,SAAS,GAGX,IAA6B,IAAzB6D,EAAQG,GAEV,OAAO,EAGT,IAAK,MAAMvD,KAAYuD,EAErB,GAAIA,EAAYvD,IAAaA,KAAYV,IAElCA,EAAiBU,GAAUwC,EAASc,GAEvC,QAKLN,GAIP,MAAMQ,EAAU9F,EAASuD,GAEzB,GAAIuC,EAAOxN,OAAS,EACpB,CACE,MAAMyN,EAAkB/E,EAAiB8E,EAAQhJ,EAAOF,EAAW6C,GAEnE,IAAK,MAAMpF,KAAS0L,EAAgBzH,SAElCwG,EAAQjE,YAAYxG,GAIxB,OAAOoF,GG/FP,WFT2C,CAACP,EAAUtC,EAAWE,EAAO1G,KAExE,MAAO+I,GAAOD,EACRO,EAAyB,CAAErJ,SAAQwG,YAAWE,QAAOwB,SAAU,CAAC6C,SAASwC,cAAc,aAC7F,IAAIqC,EAmBJ,OAjBAlJ,EAAMlD,MAAMuF,EAAM8G,IAEhB/G,EAAS,GAAK+G,EAEVD,GAEFA,EAAU3P,UAGZ2P,EAAYlJ,EAAMzB,cAElB,MAAM6K,EAAkB/H,EAAQe,EAAUtC,EAAWoJ,EAAW5P,GAEhEiI,EAAeoB,EAASnB,SAAU4H,EAAgB5H,YAEjD,GAAM,GAEFmB,GEbP,aCP6C,CAACP,EAAUiH,EAAiBrJ,EAAO1G,KAEhF,MAAOoG,EAAIK,EAAO6C,EAAQ6D,GAAcrE,EAClCkH,EAAgB3J,EAAkBD,GAClC6J,EAAa,IAAI,EAAW,KAAM,CAAErI,KAAM,GAAIwB,KAAM,KACpD5C,EAAY,IAAI,EAAkBwJ,EAAevJ,EAAOwJ,EAAYpG,EAAasD,GAAcA,OAAazE,EAAWqH,EAAiBrJ,GACxIwJ,EAASzJ,aAAK,EAALA,EAAO0J,IAOtB,GALID,UAEKzJ,EAAM0J,IAGXH,EAAchJ,WAEhB,IAAK,MAAM7C,KAAQ6L,EAAchJ,WACjC,CACE,MAAM4H,EAAYoB,EAAchJ,WAAW7C,GACrC4C,EAAa6H,aAAqB,OACpC,CAAEwB,KAAMxB,GACRA,EAEJ,GAAI7H,EAAWsJ,SAEb,SAGF,MAAMC,EAAY7J,GAAStC,KAAQsC,EAAQA,EAAMtC,GAAQ4C,EAAWG,QAEpE,GAAI,EAAM+D,YAAYqF,GACtB,CACE,IAAI1L,GAAQ,EAEZ8B,EAAMlD,MAAM8M,EAAYzB,IAEtBoB,EAAW1N,IAAI4B,EAAM0K,GAAG,GAEpBjK,GAASmC,EAAWwJ,QAEtBxJ,EAAWwJ,QAAQ1B,EAAGrI,IAEd5B,GAASmC,EAAWyJ,SAE5BzJ,EAAWyJ,QAAQ3B,EAAGrI,GAEpBO,EAAWrG,QAEbqG,EAAWrG,OAAOmO,EAAGrI,IAGlB5B,GAASoL,EAAclI,SAE1BkI,EAAclI,QAAQtB,GAGxB5B,GAAQ,SAKVqL,EAAW1N,IAAI4B,EAAMmM,GAAW,GAKtC,GAAIN,EAAczG,MAEhB,IAAK,MAAMkH,KAAaT,EAAczG,MACtC,CACE,MAAMmH,EAAaV,EAAczG,MAAMkH,GAEvCR,EAAW1N,IAAIkO,EAAWR,EAAWtL,KAAK+L,EAAhBT,IAA+B,GAI7D,GAAID,EAAcxG,SAEhB,IAAK,MAAMmH,KAAgBX,EAAcxG,SACzC,CACE,MAAMoH,EAAgBZ,EAAcxG,SAASmH,GAE7CV,EAAWzM,MAAMoN,EAAgBtT,IAE/B2S,EAAW1N,IAAIoO,EAAcrT,GAAO,KAK1C,GAAI,mBAASgM,IAAW0G,EAAc1G,OAEpC,IAAK,MAAMqC,KAAMrC,EACjB,CACE,KAAMqC,KAAMqE,EAAc1G,QAExB,SAGF,MAAM2F,EAAa3F,EAAOqC,GAE1B,GAAI,EAAMV,YAAYgE,GACtB,CACE,MAAMpH,EAAWnB,EAAM/B,KAAKsK,GAE5BzI,EAAUqK,GAAGlF,EAAI9D,IAKvB,MACMwB,EAAWtB,EADAiI,EAAchI,OAAOxB,GACHA,EAAWyJ,EAAYjQ,GAc1D,OAZAwG,EAAU1B,KAAOuE,EAEb2G,EAAcc,SAEhBd,EAAcc,QAAQtK,GAGpB0J,GAAUH,IAEZA,EAAgBrJ,MAAM7C,SAASuF,KAAK8G,GAAUD,EAAWpM,UAGpDwF,GDnHP,MEZsC,EAAEN,EAAKtC,EAAO6C,EAAQ6D,GAAa3G,EAAWE,EAAO1G,IAC3FkN,EAAe,CAACnE,EAAK,OAAF,QAAIzL,OAAO,GAASmJ,GAAS6C,EAAQ6D,GAAa3G,EAAWE,EAAO1G,GFYvF,QNLwC,CAAC8I,EAAUtC,EAAWE,EAAO1G,KAErE,MAAO,CAAEyG,EAAO,CAAE0G,GAAcrE,EAE1BO,EAAyB,CAAErJ,SAAQwG,YAAWE,QAAOwB,SAD3C,CAAC6C,SAASwC,cARS,UAWnC,GAAI9G,EACJ,CACE,MAAM0B,EAAW1B,EAAM7J,MDnBC,UCoBlB4L,EAAY/B,EAAM+B,WACpB9B,EAAM/B,KAAK8B,EAAM+B,UAAjB9B,IACA,EACEqK,EAAiBnH,EAASpD,EAAUG,MAAOwB,EAAUK,GACrDwI,EAAeD,EAAe7O,OAAS,EACvCyE,EAAQqK,EACVD,EACAnH,EAASuD,EAAYhF,EAAUK,GAC7ByI,EAAYD,EACdxK,EAAUI,WAAW3B,cACrByB,EAAMzB,cAEV,GAAIwB,EAAM+B,UACV,CACE,MAAM0I,EAAc1K,EAAU6B,eAAeF,GACvCgJ,EAAgBD,GAClBA,EAAYE,iBA5B0B,YA+B1CH,EAAU1O,IAAI4O,EAAe3I,GAG/B,GAAI/B,EAAMC,MAER,IAAK,MAAM2K,KAAY5K,EAAMC,MAC7B,CACE,MAAM4K,EAAa7K,EAAMC,MAAM2K,GAE3B,EAAMpG,YAAYqG,GAEpB5K,EAAMlD,MAAM8N,EAAahU,IAEvB2T,EAAU1O,IAAI8O,EAAU/T,GAAO,KAKjC2T,EAAU1O,IAAI8O,EAAUC,GAAY,GAK1C,GAAI3K,EACJ,CACE,MAAM4K,EAAa3G,EAAiBjE,EAAOsK,EAAWzK,EAAW6C,GAEjEA,EAASnB,SAAWqJ,EAAWrJ,UAInC,OAAOmB,GMrDP,OGduC,CAACP,EAAUtC,EAAWE,EAAO1G,KAEpE,MAAO,CAAEyG,EAAO,CAAE0G,GAAcrE,EAC1BwE,EAAcvC,SAASwC,cAAc,OAErClE,EAAyB,CAAErJ,SAAQwG,YAAWE,QAAOwB,SAD3C,CAACoF,IAEXkE,EAAe5H,EAASuD,GAE9B,GAAI1G,GAASA,EAAMgL,MACnB,CACE,MAAMC,EAAWjL,EAAMxH,MAAQ,OACzB0S,EAAYlL,EAAM3H,OAAS,QAC3B8S,EAAUnL,EAAM7I,KAAO,QAAMV,IAAIyU,GAEjC/T,EAAM8I,EAAM/B,KAAKiN,GACjBhF,EAAM,IAAIiF,IAEhBnL,EAAMlD,MAAMiD,EAAMgL,MAAQA,IAExB,MAAMK,EAAsB,CAACxE,GACvByE,EAAO,IAAI9H,KA0CvB,SAA2B3D,EAAiB0L,GAE1C,GAAI,kBAAQ1L,GAEV,IAAK,IAAIxH,EAAQ,EAAGA,EAAQwH,EAAWpE,OAAQpD,IAE7CkT,EAAS1L,EAAWxH,GAAQA,QAG3B,GAAI,gBAAMwH,GACf,CACE,IAAIxH,EAAQ,EAEZ,IAAK,MAAMG,KAAQqH,EAEjB0L,EAAS/S,EAAMH,UAGd,GAAI,gBAAMwH,GAEb,IAAK,MAAO1I,EAAKN,KAAUgJ,EAAW2L,UAEpCD,EAAS1U,EAAOM,QAGf,GAAI,mBAAS0I,GAEhB,IAAK,MAAM1I,KAAO0I,EAEhB0L,EAAS1L,EAAW1I,GAAM0I,QAGzB,GAAI,mBAASA,GAEhB,IAAK,IAAIjK,EAAI,EAAGA,EAAIiK,EAAYjK,IAE9B2V,EAAS3V,EAAGA,GA5EZ6V,CAAkBT,EAAO,CAACxS,EAAMkT,KAE9B,MAAMC,EAAgB,CAAE,CAACV,GAAWzS,EAAM,CAAC0S,GAAYQ,GACjDE,EAAUzU,EAAI,OAAD,UAAMwU,IACzB,IAAIE,EAAiB1F,EAAI1P,IAAImV,GAE7B,GAAKC,EAUHA,EAAeC,aAAaH,OAT9B,CACE,MAAMI,EAAY9L,EAAMzB,YAAYmN,GAEpCE,EAAiB1H,EAAiB4G,EAAcgB,EAAWhM,EAAW6C,GAEtEuD,EAAIrK,IAAI8P,EAASC,GAOnBP,EAAKU,IAAIJ,GACTP,EAAY5S,QAAQoT,EAAepK,YAGrCD,EAAeoB,EAASnB,SAAU4J,GAElClF,EAAIjO,QAAQ,CAAC2T,EAAgBH,KAEtBJ,EAAKzN,IAAI6N,KAEZG,EAAerS,UAEf2M,EAAItC,OAAO6H,QAMnB,OAAO9I,GH5CP,UAAoB6D,GIbf,SAASwF,EAASC,EAA4BC,EAA6BpV,EAAmB,UAEjG,OAAOqV,EAAU,CAAC,CAACF,EAAWC,SAAUlK,EAAWlL,GAGhD,SAASsV,EAAaH,EAA4BC,EAA6BG,EAA4BvV,EAAmB,UAEjI,OAAOqV,EAAU,CAAC,CAACF,EAAWC,IAAUG,EAAOvV,GAG5C,SAASqV,EAAUpF,EAAiDuF,EAAiCxV,EAAmB,UAE3H,MAAO,CXbiB,MWaF,CAClBA,OACAiQ,MAAOA,EAAMwF,OAAO,CAACjU,GAAMyE,GAAQ7F,KAASoB,EAAIpB,GAAO6F,EAAMzE,GAAM,KACpE,GAAI,OAAF,wBACEyO,EAAMwF,OAAO,CAACjU,GAAM,CAACkU,GAAOtV,KAASoB,EAAIpB,GAAOsV,EAAMlU,GAAM,KAAG,CAClEkI,QAAS8L,KAIV,SAASG,EAAWR,EAA4BC,GAEnD,OAAOC,EAAU,CAAC,CAACF,EAAWC,SAAUlK,EAAW,QAGhD,SAAS0K,EAAWT,EAA4BC,GAEnD,OAAOC,EAAU,CAAC,CAAC,QAAMQ,IAAIV,GAAYC,SAAUlK,EAAW,QAG3D,SAAS4K,EAAahW,EAAwBmQ,EAAiD8F,EAA+B3F,GAEjI,MAAO,CXjCqB,UWiCF,CACtBtQ,QACAmQ,MAAOA,EAAMwF,OAAO,CAACjU,GAAMyE,GAAQ7F,KAASoB,EAAIpB,GAAO6F,EAAMzE,GAAM,IACnE4O,WACD,GAAI,OAAF,wBACEH,EAAMwF,OAAO,CAACjU,GAAM,CAACkU,GAAOtV,KAASoB,EAAIpB,GAAOsV,EAAMlU,GAAM,KAAG,CAClEkI,QAASqM,KAIV,SAASC,EACZhN,EACAQ,EAA0E,GAC1EsC,EAAoD,GACpD3C,EAAmG,IAEnG,MAAO,CAAC,GAAGH,EAAUF,cAAcE,EAAU5J,OACzCoK,EACAsC,EACA3C,GAID,SAAS8M,EAAUhC,EAAmBvN,EAA+BkE,EAAoE,IAE5I,MAAO,CXzDkB,OWyDF,OAAF,QACjBqJ,SACGrJ,GACJ,GACClE,GAID,SAASwP,EAAWjN,EAAgGvC,EAAgC,IAEvJ,MAAO,CXlEmB,QWkEFuC,EAAO,GAAIvC,GCzEvC,uCZA4B,aYA5B,2CZCgC,OYDhC,2CZEgC,cYFhC,6CZGkC,gBYHlC,uCZI4B,SYJ5B,2CZKgC,aYLhC,wCZM6B,UYN7B,yCZO8B,WYP9B","file":"expangine-ui.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"expangine-runtime\", \"expangine-runtime-live\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"expangine-ui\"] = factory(require(\"expangine-runtime\"), require(\"expangine-runtime-live\"));\n\telse\n\t\troot[\"expangine-ui\"] = factory(root[\"expangine-runtime\"], root[\"expangine-runtime-live\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","/**\n * The hidden property which stores the reference to the Observer for an object.\n */\nexport var PROPERTY = '$obs';\n/**\n * This is a map of array functions which modify the contents of an array. When\n * this happens the observed array is checked for referential and length changes.\n */\nexport var ARRAY_CHANGES = {\n    'pop': 1,\n    'push': 1,\n    'shift': 1,\n    'unshift': 1,\n    'reverse': 1,\n    'splice': 1,\n    'sort': 1,\n};\n/**\n * This is a map of array functions which can return different results when the\n * array is modified with the above functions. When these functions are called\n * the watch function observes all items in the array and it's length.\n */\nexport var ARRAY_ITERATIONS = {\n    'concat': 1,\n    'every': 1,\n    'fill': 1,\n    'filter': 1,\n    'find': 1,\n    'findIndex': 1,\n    'forEach': 1,\n    'includes': 1,\n    'indexOf': 1,\n    'join': 1,\n    'lastIndexOf': 1,\n    'map': 1,\n    'reduce': 1,\n    'reduceRight': 1,\n    'slice': 1,\n    'some': 1,\n};\n//# sourceMappingURL=Constants.js.map","/**\n * A node in a doubly-linked list. The functions in this class are mostly\n * intended for use by the head node. A default head node points to itself and\n * has a null value. A node always has a next or previous node reference.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Creates a new node given a value.\n     *\n     * @param value The value for the node.\n     */\n    function Node(value) {\n        this.value = value;\n        this.next = this.prev = this;\n    }\n    /**\n     * Iterates over the nodes in the linked list and returns the number of nodes\n     * in the list.\n     *\n     * @param iterator The function to call with the value of the node, the\n     *    reference to the node (useful for removing the value from the list),\n     *    and the index of the value in the list starting at the next node.\n     */\n    Node.prototype.forEach = function (iterator) {\n        var curr = this.next;\n        var index = 0;\n        while (curr !== this) {\n            var next = curr.next;\n            iterator(curr.value, curr, index);\n            curr = next;\n            index++;\n        }\n        return index;\n    };\n    /**\n     * Returns the items in this list as an array.\n     */\n    Node.prototype.toArray = function () {\n        var out = [];\n        this.forEach(function (item) { return out.push(item); });\n        return out;\n    };\n    /**\n     * Inserts this Node after the given node.\n     *\n     * @param prev The node to insert this Node after.\n     */\n    Node.prototype.insertAfter = function (prev) {\n        this.next = prev.next;\n        this.prev = prev;\n        this.prev.next = this.next.prev = this;\n    };\n    /**\n     * If this is the head of a list, this function adds a node to the very end\n     * of the list. This is also equivalent to adding the given node directly\n     * before this node.\n     *\n     * @param last The node to insert at the end of the list / before this node.\n     */\n    Node.prototype.push = function (last) {\n        last.insertAfter(this.prev);\n    };\n    /**\n     * If this Node is in a list, it removes itself from the list.\n     */\n    Node.prototype.remove = function () {\n        if (!this.isEmpty()) {\n            this.next.prev = this.prev;\n            this.prev.next = this.next;\n            this.prev = this.next = this;\n        }\n    };\n    /**\n     * Returns whether the list this node is in is empty.\n     */\n    Node.prototype.isEmpty = function () {\n        return this.next === this;\n    };\n    /**\n     * Returns a new node for the head of the list.\n     */\n    Node.head = function () {\n        return new Node(null);\n    };\n    return Node;\n}());\nexport { Node };\n//# sourceMappingURL=Node.js.map","import { Node } from './Node';\n/**\n * A dependency is a property of an object or an item in an array.\n */\nvar Dependency = /** @class */ (function () {\n    /**\n     * Creates a new Dependency.\n     *\n     * @param observer The observer for the object.\n     */\n    function Dependency(observer) {\n        this.observer = observer;\n        this.links = Node.head();\n    }\n    /**\n     * Notifies all observing watchers that this dependency has changed. If any\n     * of the watchers are watching for deep (sub) changes the parent dependency\n     * is notified.\n     *\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Dependency.prototype.notify = function (notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deep = false;\n        // We need to iterate over a copy, otherwise it could get stuck in an infinite loop.\n        this.links.toArray().forEach(function (link) {\n            link.watcher.notify();\n            deep = deep || link.watcher.deep;\n        });\n        if (notifyParent && deep && this.observer.parent) {\n            this.observer.parent.notify(notifyParent);\n        }\n        return deep;\n    };\n    /**\n     * Destroys the depdendency removing it from all watchers.\n     */\n    Dependency.prototype.destroy = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    return Dependency;\n}());\nexport { Dependency };\n//# sourceMappingURL=Dependency.js.map","import { Node } from './Node';\n/**\n * An array of watcher functions which are currently executing.\n */\nexport var liveWatchers = [];\n/**\n * A class which holds a user supplied function and list of observed\n * depdendencies it references. When any of those dependencies change a watcher\n * is notified.\n */\nvar Watcher = /** @class */ (function () {\n    /**\n     * Creates a new Watcher given an expression, if it's immediate, and if the\n     * watches are deep.\n     */\n    function Watcher(expression, immediate, deep) {\n        if (immediate === void 0) { immediate = true; }\n        if (deep === void 0) { deep = false; }\n        this.expression = expression;\n        this.immediate = immediate;\n        this.deep = deep;\n        this.dirty = false;\n        this.paused = false;\n        this.evaluating = false;\n        this.links = Node.head();\n    }\n    /**\n     * Determines whether the watch function is currently observing anything for\n     * changes.\n     */\n    Watcher.prototype.isWatching = function () {\n        return !this.links.isEmpty();\n    };\n    /**\n     * Notifies the watcher that a dependency has changed.\n     */\n    Watcher.prototype.notify = function () {\n        if (this.evaluating) {\n            return;\n        }\n        this.dirty = true;\n        if (this.immediate) {\n            this.update();\n        }\n    };\n    /**\n     * Executes the function and gathers a new list of dependencies.\n     */\n    Watcher.prototype.update = function () {\n        this.evaluating = true;\n        this.off();\n        liveWatchers.push(this);\n        try {\n            this.result = this.expression();\n        }\n        finally {\n            liveWatchers.pop();\n            this.dirty = false;\n            if (this.onResult) {\n                try {\n                    this.onResult();\n                }\n                finally {\n                    this.evaluating = false;\n                }\n            }\n            this.evaluating = false;\n        }\n    };\n    /**\n     * Stops watching for changes.\n     */\n    Watcher.prototype.off = function () {\n        this.links.forEach(function (link) { return link.remove(); });\n    };\n    /**\n     * Stops watching for changes and marks the watcher as paused.\n     */\n    Watcher.prototype.pause = function () {\n        if (!this.paused) {\n            this.off();\n            this.paused = true;\n        }\n    };\n    /**\n     * Resumes watching for changes if the watcher was paused.\n     */\n    Watcher.prototype.resume = function () {\n        if (this.paused) {\n            this.update();\n            this.paused = false;\n        }\n    };\n    return Watcher;\n}());\nexport { Watcher };\n//# sourceMappingURL=Watcher.js.map","import { Node } from './Node';\n/**\n * A relationship between a Watcher and Dependency which stores both links so\n * the lists stored in the watcher and dependency can both be removed from\n * instantly.\n */\nvar Link = /** @class */ (function () {\n    /**\n     * Creates a new Link given the Watcher and Dependency.\n     */\n    function Link(watcher, dependency) {\n        this.watcher = watcher;\n        this.dependency = dependency;\n        this.watcherNode = new Node(this);\n        this.dependencyNode = new Node(this);\n    }\n    /**\n     * Removes the relationship between the Watcher and Dependency.\n     */\n    Link.prototype.remove = function () {\n        this.watcherNode.remove();\n        this.dependencyNode.remove();\n    };\n    /**\n     * Creates a link between the given Watcher and Dependency. If a link already\n     * exists, then this function has no effect. If a link does not exist, one is\n     * created and added to both the dependency and watcher lists. A link\n     * reference is always returned.\n     */\n    Link.create = function (watcher, dependency) {\n        var existing = null;\n        dependency.links.forEach(function (link) { return existing = (link.watcher === watcher ? link : existing); });\n        if (!existing) {\n            existing = new Link(watcher, dependency);\n            dependency.links.push(existing.dependencyNode);\n            watcher.links.push(existing.watcherNode);\n        }\n        return existing;\n    };\n    return Link;\n}());\nexport { Link };\n//# sourceMappingURL=Link.js.map","import { PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS } from './Constants';\nimport { Link } from './Link';\nimport { liveWatchers } from './Watcher';\nimport { observe, isObservable, isObserved } from './observe';\n/**\n * The handler to pass to the Proxy constructor.\n */\nexport var handler = {\n    /**\n     * Intercepts the property getting so any watch functions can gather its list\n     * of dependencies.\n     */\n    get: function (target, prop, _reciever) {\n        var val = target[prop];\n        if (prop === PROPERTY) {\n            return val;\n        }\n        var obs = target[PROPERTY];\n        if (typeof val === 'function') {\n            if (target instanceof Array) {\n                if (prop in ARRAY_CHANGES) {\n                    return handleArrayChange(target, val, obs);\n                }\n                if (prop in ARRAY_ITERATIONS) {\n                    return handleArrayIteration(target, val, obs);\n                }\n            }\n            return val;\n        }\n        return handleWatching(target, prop, val, obs);\n    },\n    /**\n     * Intercepts the property setting so all dependent watchers are notified,\n     */\n    set: function (target, prop, value, _reciever) {\n        if (value !== target[prop]) {\n            target[prop] = value;\n            var obs = target[PROPERTY];\n            obs.notify(prop, true);\n        }\n        return true;\n    },\n    /**\n     * Intercepts the property delete operator so all dependent watchers no longer\n     * listen to changes.\n     */\n    deleteProperty: function (target, prop) {\n        var obs = target[PROPERTY];\n        obs.remove(prop);\n        return true;\n    }\n};\n/**\n * If a property on an object contains an observable object/array which is not\n * yet being observered - it is replaced with a proxy. The value of the property\n * is returned.\n */\nfunction handleWatching(target, prop, val, obs) {\n    var dep = obs.dep(prop);\n    liveWatchers.forEach(function (watcher) { return Link.create(watcher, dep); });\n    if (isObservable(val) && !isObserved(val)) {\n        target[prop] = val = observe(val, { parent: dep });\n    }\n    return val;\n}\n/**\n * Returns a function which ensures when its called that all items and the\n * length of the array is watched by any live watchers.\n */\nfunction handleArrayIteration(target, val, obs) {\n    return function () {\n        var length = target.length;\n        for (var i = 0; i < length; i++) {\n            handleWatching(target, i, target[i], obs);\n        }\n        handleWatching(target, 'length', target.length, obs);\n        return val.apply(target, arguments);\n    };\n}\n/**\n * Returns a function which notifies any watched functions of changes after a\n * mutating array operation is executed.\n */\nfunction handleArrayChange(target, val, obs) {\n    return function () {\n        var copy = target.slice();\n        var result = val.apply(target, arguments);\n        var max = Math.max(copy.length, target.length);\n        var deepNotified = false;\n        for (var i = 0; i < max; i++) {\n            if (copy[i] !== target[i]) {\n                deepNotified = deepNotified || obs.notify(i);\n            }\n            if (i >= target.length) {\n                obs.remove(i);\n            }\n        }\n        if (target.length !== copy.length) {\n            deepNotified = deepNotified || obs.notify('length');\n        }\n        if (deepNotified && obs.parent) {\n            obs.parent.notify(true);\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=handler.js.map","import { PROPERTY } from './Constants';\nimport { Observer } from './Observer';\nimport { handler } from './handler';\n/**\n * Observes the object/array if is not yet observed. An observed object is one\n * that can be used in watch functions and will trigger then when referenced\n * values in the observed object changes.\n *\n * @param input The object/array to observe for changes.\n * @returns The reference to the object/array or the Proxy if it is observable\n *    and has not yet been observed.\n */\nexport function observe(input, _a) {\n    var _b = (_a === void 0 ? {} : _a).parent, parent = _b === void 0 ? null : _b;\n    if (isObservable(input)) {\n        if (!input[PROPERTY]) {\n            var proxy = Proxy.revocable(input, handler);\n            input = proxy.proxy;\n            Object.defineProperty(input, PROPERTY, {\n                value: new Observer(proxy.revoke, parent),\n                writable: false,\n                configurable: true,\n                enumerable: false\n            });\n        }\n    }\n    return input;\n}\n/**\n * Determines whether the given input can be observed.\n *\n * @param input The input to test.\n */\nexport function isObservable(input) {\n    return !!(typeof input === 'object' && input !== null);\n}\n/**\n * Determines whether the given input is currently being observed.\n *\n * @param input The input to check for observation.\n */\nexport function isObserved(input) {\n    return !!(typeof input === 'object' && input !== null && input[PROPERTY]);\n}\n//# sourceMappingURL=observe.js.map","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\nimport { Dependency } from './Dependency';\n/**\n * An observer is for an object/array and keeps track of all watched properties.\n * If the observer belongs to a sub-object on an observed object then it has a\n * parent. This parent reference is needed for deeply watched objects.\n */\nvar Observer = /** @class */ (function () {\n    /**\n     * Creates a new Observer.\n     *\n     * @param parent An optional parent dependency.\n     */\n    function Observer(revoke, parent) {\n        if (parent === void 0) { parent = null; }\n        this.revoke = revoke;\n        this.parent = parent;\n        this.deps = Object.create(null);\n    }\n    /**\n     * Returns a Dependency for the given property and creates it if it doesn't\n     * exist already.\n     *\n     * @param prop The name of the property or the index of the array element.\n     */\n    Observer.prototype.dep = function (prop) {\n        var dep = this.deps[prop];\n        if (!dep) {\n            this.deps[prop] = dep = new Dependency(this);\n        }\n        return dep;\n    };\n    /**\n     * If the given property or array element is being watched, all watchers will\n     * be notified.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    notify of changes.\n     * @param notifyParent If a deep watcher is listening on this dependency,\n     *    should we notify the parent of the observer?\n     * @returns True if a deep watcher was notified.\n     */\n    Observer.prototype.notify = function (prop, notifyParent) {\n        if (notifyParent === void 0) { notifyParent = false; }\n        var deps = this.deps;\n        if (prop in deps) {\n            return deps[prop].notify(notifyParent);\n        }\n        else if (notifyParent && this.parent) {\n            this.parent.notify(notifyParent);\n        }\n        return false;\n    };\n    /**\n     * Removes the given property or array element so it's no longer observed for\n     * changes.\n     *\n     * @param prop The name of the property or the index of the array element to\n     *    cease watching on.\n     */\n    Observer.prototype.remove = function (prop) {\n        var deps = this.deps;\n        if (prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n        }\n    };\n    /**\n     * Destroys this observer by destroying all dependents.\n     *\n     * @param target The object which holds this observer.\n     * @param deep If any descendant objects should be destroyed as well.\n     * @param revoke If the proxy should be revoked, making the object unusable.\n     */\n    Observer.prototype.destroy = function (target, deep, revoke) {\n        if (deep === void 0) { deep = false; }\n        if (revoke === void 0) { revoke = true; }\n        var deps = this.deps;\n        for (var prop in deps) {\n            deps[prop].destroy();\n            delete deps[prop];\n            if (deep) {\n                var value = target[prop];\n                if (isObserved(value)) {\n                    var obs = value[PROPERTY];\n                    obs.destroy(value, deep, revoke);\n                }\n            }\n        }\n        if (revoke) {\n            this.revoke();\n        }\n    };\n    return Observer;\n}());\nexport { Observer };\n//# sourceMappingURL=Observer.js.map","import { Watcher } from './Watcher';\n/**\n * Given a function to execute, any observed objects/arrays which are referenced\n * in that function are tracked. If they change the given function will execute\n * again and a new list of dependencies is generated. A Watcher instance is\n * returned which can be used to pause, resume, or stop watching for changes.\n *\n * @param expr The function to execute when any referenced observed values change.\n * @param immediate If the function should executed as soon as a dependent value\n *    changes (true), or simply mark the returned Watcher instance as dirty (false).\n * @param deep If true, not only does the function execute when referenced\n *    values change, but also nested values.\n * @returns A new instance of Watcher.\n */\nexport function watch(expr, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.immediate, immediate = _c === void 0 ? true : _c, _d = _b.deep, deep = _d === void 0 ? false : _d;\n    var watcher = new Watcher(expr, immediate, deep);\n    watcher.update();\n    return watcher;\n}\n//# sourceMappingURL=watch.js.map","import { Expression, DataTypes } from 'expangine-runtime';\nimport { LiveContext, LiveRuntime } from 'expangine-runtime-live';\nimport { Watcher, Node as LinkedNode, observe, unobserve, watch } from 'scrute';\nimport { Off } from './Node';\n\n\nexport class Scope<A extends LiveContext = any> \n{\n\n  public parent: Scope | null;\n  public observed: A;\n  public link: LinkedNode<Scope<A>>;\n  public children?: LinkedNode<Scope<A>>;\n  public disables: number;\n  public watchers: LinkedNode<Watcher>;\n  \n  public constructor(parent: Scope | null = null, data: A = Object.create(null)) \n  {\n    this.parent = parent;\n    this.observed = observe(data);\n    this.disables = 0;\n    this.link = new LinkedNode(this);\n    this.watchers = LinkedNode.head();\n  }\n\n  public createChild(data: any = {}, addToParent: boolean = true): Scope \n  {\n    const child = new Scope(this, data);\n\n    if (addToParent)\n    {\n      if (!this.children)\n      {\n        this.children = LinkedNode.head();\n      }\n\n      this.children.push(child.link);\n    }\n    \n    return child;\n  }\n\n  public get<V extends keyof A>(attr: V, defaultValue?: A[V], here: boolean = false): A[V] \n  {\n    return attr in this.observed \n      ? this.observed[attr]\n      : this.parent && !here\n        ? this.parent.get(attr, defaultValue)\n        : defaultValue;\n  }\n\n  public has(attr: string | number | symbol, here: boolean = false): attr is (keyof A)\n  {\n    return attr in this.observed\n      ? true\n      : this.parent && !here\n        ? this.parent.has(attr)\n        : false;\n  }\n\n  public set<V extends keyof A>(attr: V, value: A[V], here: boolean = false): boolean \n  {\n    if (attr in this.observed || here)\n    {\n      this.observed[attr] = value;\n    }\n    else if (this.parent)\n    {\n      if (!this.parent.set(attr, value))\n      {\n        this.observed[attr] = value;\n      }\n    }\n    else\n    {\n      return false;\n    }\n\n    return true;\n  }\n\n  public remove<V extends keyof A>(attr: V): void \n  {\n    if (attr in this.observed)\n    {\n      delete this.observed[attr];\n    }\n    else if (this.parent)\n    {\n      this.parent.remove(attr);\n    }\n  }\n\n  public setMany(values: Partial<A>) \n  {\n    for (const prop in values)\n    {\n      this.set(prop, values[prop]);\n    }\n  }\n\n  public watch(expr: any, onValue: (value: any) => void, immediate: boolean = true, equalityCheck: boolean = false): Off \n  {\n    const cmd = LiveRuntime.eval(expr);\n    let first: boolean = true;\n    let last: any;\n\n    const watcher = watch(() => {\n      const result = cmd(this);\n\n      if (immediate || !first) {\n        if (first || (!equalityCheck || !DataTypes.equals(last, result))) {\n          onValue(result);\n        }\n      }\n\n      last = equalityCheck ? DataTypes.copy(result) : result;\n      first = false;\n    });\n\n    const node = new LinkedNode(watcher);\n\n    this.watchers.push(node);\n\n    return () => {\n      watcher.off();\n      node.remove();\n    };\n  }\n\n  public eval(expr: any): ((extra?: any) => any) \n  {\n    const cmd = LiveRuntime.eval(expr);\n\n    return (extra) => \n    {\n      if (extra)\n      {\n        const extraScope = this.createChild(extra);\n        const result = cmd(extraScope);\n\n        extraScope.destroy();\n\n        return result;\n      }\n      else\n      {\n        return cmd(this);\n      }\n    }\n  }\n\n  public enable(): void \n  {\n    if (this.disables > 0) \n    {\n      this.disables--;\n      \n      if (this.disables === 0) \n      {\n        this.watchers.forEach((w) => w.resume());\n      }\n\n      if (this.children) \n      {\n        this.children.forEach((c) => c.enable());\n      }\n    }\n  }\n\n  public disable(): void \n  {\n    if (this.disables === 0) \n    {\n      this.watchers.forEach((w) => w.pause());\n    }\n    \n    if (this.children) \n    {\n      this.children.forEach((c) => c.disable());\n    }\n\n    this.disables++;\n  }\n\n  public setEnabled(enabled: boolean) \n  {\n    enabled ? this.enable() : this.disable();\n  }\n\n  public destroy(): void \n  {\n    this.link.remove();\n    this.disables = Number.MAX_SAFE_INTEGER;\n    this.watchers.forEach((w) => w.off());\n    \n    if (this.children) \n    {\n      this.children.forEach((c) => c.destroy());\n    }\n\n    unobserve(this.observed);\n  }\n\n  private static registered: boolean = false;\n\n  public static register()\n  {\n    if (!this.registered)\n    {\n      const { dataSet, dataGet, dataHas, dataRemove } = LiveRuntime;\n\n      LiveRuntime.dataGet = (obj, prop) => obj instanceof Scope ? obj.get(prop) : dataGet(obj, prop);\n      LiveRuntime.dataSet = (obj, prop, value) => obj instanceof Scope ? obj.set(prop, value) : dataSet(obj, prop, value);\n      LiveRuntime.dataHas = (obj, prop) => obj instanceof Scope ? obj.has(prop) : dataHas(obj, prop);\n      LiveRuntime.dataRemove = (obj, prop) => obj instanceof Scope ? obj.remove(prop) : dataRemove(obj, prop);\n\n      this.registered = true;\n    }\n  }\n\n  public static isWatchable(x: any): x is (Expression | [string, ...any[]])\n  {\n    return LiveRuntime.defs.isExpression(x);\n  }\n\n}\n\n\nScope.register();","import { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\n/**\n * Stops all observations for the given variable. Optionally it can travel\n * through all descendant observers and unobserve them as well.\n *\n * @param input The possibly observed object.\n * @param deep If all descendant observers should be unobserved.\n * @param destroy If the proxy should be destroyed, making it unusable.\n * @returns The reference to the value passed to this function.\n */\nexport function unobserve(input, deep, destroy) {\n    if (deep === void 0) { deep = false; }\n    if (destroy === void 0) { destroy = true; }\n    if (isObserved(input)) {\n        var obs = input[PROPERTY];\n        delete input[PROPERTY];\n        obs.destroy(input, deep, destroy);\n    }\n    return input;\n}\n//# sourceMappingURL=unobserve.js.map","import { Component } from './Component';\n\nexport function addComponent<A = never, E = never, S extends string = never, L = never, C = never>(comp: Component<A, E, S, L, C>, id?: string)\n{\n  ComponentRegistry[id || `${comp.collection}/${comp.name}`] = comp as any;\n\n  return comp;\n}\n\nexport const ComponentRegistry: Record<string, Component<any, any, any, any, any>> = Object.create(null);","import { Exprs, Expression, ExpressionValue, defs, isObject, isNumber } from 'expangine-runtime';\nimport { Scope } from './Scope';\nimport { Component, ComponentValue, ComponentSlot } from './Component';\nimport { NodeInstance, NodeTemplateNamedSlots, Off, changeElements } from './Node';\nimport { compile } from './compile';\nimport { isComponentSlot } from './compilers/slot';\nimport { DEFAULT_SLOT } from './constants';\n\n\nexport type ComponentInstanceAny = ComponentInstance<any, any, any, any, any>;\n\nexport class ComponentInstance<A, E, S extends string, L, C> \n{\n  public component: Component<A, E, S, L, C>;\n  public attrs: Partial<Record<keyof A, ExpressionValue>>;\n  public cache: Record<string, any>;\n  public scope: Scope<A & L & C & { emit: E, refs: Record<string, any> }>;\n  public outerScope: Scope;\n  public node?: NodeInstance;\n  public parent?: ComponentInstanceAny;\n  public slots?: NodeTemplateNamedSlots;\n\n  public constructor(component: Component<A, E, S, L, C>, attrs: Partial<Record<keyof A, ExpressionValue>>, scope: Scope, slots?: NodeTemplateNamedSlots, parent?: ComponentInstanceAny, outerScope?: Scope) \n  {\n    this.component = component;\n    this.attrs = attrs;\n    this.scope = scope;\n    this.outerScope = outerScope || scope;\n    this.slots = slots;\n    this.parent = parent;\n    this.cache = Object.create(null);\n  }\n\n  public call<K extends keyof A>(attr: K, args: Record<string, ExpressionValue>): Expression\n  {\n    const attrObject = (this.component as any as Component<any, any, any, any, any>).attributes?.[attr];\n    const attrValue = this.attrs[attr];\n    const attrExpr = attrValue || (attrObject as ComponentValue<any, any, any, any, any, string>)?.default;\n\n    if (attrExpr)\n    {\n      const def = Exprs.define();\n      \n      for (const arg in args)\n      {\n        def.with(arg, defs.getExpression(args[arg]));\n      }\n\n      def.run(defs.getExpression(attrExpr));\n\n      return def;\n    }\n\n    return Exprs.noop();\n  }\n\n  public trigger<K extends keyof E>(eventName: K, payload: E[K], evalScope: Scope = this.scope): void\n  {\n    this.scope.observed.emit[eventName] = evalScope.eval(payload)();\n  }\n\n  public on<K extends keyof E>(eventName: K, listener: (payload: E[K]) => any): Off \n  {\n    return this.scope.watch(\n      Exprs.get('emit', eventName),\n      listener,\n      false\n    );\n  }\n\n  public update(): void \n  {\n    if (this.component.updated && this.node) \n    {\n      this.component.updated(this);\n    }\n  }\n\n  public render(): void \n  {\n    this.cache = Object.create(null);\n\n    const rendered = this.component.render(this);\n    const node = compile(rendered, this, this.scope);\n\n    changeElements(this.node.elements, node.elements);\n    \n    this.node = node;\n  }\n\n  public destroy(): void \n  {\n    this.scope.destroy();\n  }\n\n  public getSlotArrayLength(slotName: string = DEFAULT_SLOT): Expression\n  {\n    const options = this.getSlotOptions(slotName);\n\n    if (options && options.arrayLength)\n    {\n      return defs.getExpression(options.arrayLength);\n    }\n\n    if (this.slots && this.slots[slotName] && isObject(this.slots[slotName]))\n    {\n      const slots = this.slots[slotName];\n      let maxSlotIndex: number | undefined;\n\n      for (const slotIndex in slots)\n      {\n        const i = parseInt(slotIndex);\n\n        if (isNumber(i) && (maxSlotIndex === undefined || i > maxSlotIndex))\n        {\n          maxSlotIndex = i;\n        }\n      }\n\n      if (maxSlotIndex !== undefined)\n      {\n        return Exprs.const(maxSlotIndex + 1);\n      }\n    }\n\n    return Exprs.const(0);\n  }\n\n  public getSlotOptions(slotName: string): ComponentSlot | false\n  {\n    const c = this.component as any as Component<any, any, any, any, any>;\n\n    if (c.slots)\n    {\n      const slotInput = c.slots[slotName];\n\n      return isComponentSlot(slotInput)\n        ? slotInput\n        : { scope: slotInput };\n    }\n\n    return false;\n  }\n\n}","\nexport const DEFAULT_SLOT = 'default';\nexport const COMPILER_DEFAULT = '*';\nexport const COMPILER_DYNAMIC = ':dynamic';\nexport const COMPILER_COMPONENT = ':component';\nexport const DIRECTIVE_IF = ':if';\nexport const DIRECTIVE_SWITCH = ':switch';\nexport const DIRECTIVE_FOR = ':for';\nexport const DIRECTIVE_SLOT = ':slot';","import { Type, isObject } from 'expangine-runtime';\nimport { ComponentSlot } from '../Component';\nimport { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { DEFAULT_SLOT } from '../constants';\nimport { Scope } from '../Scope';\n\n\nexport const COMPILER_SLOT_COMMENT = 'slot';\n\nexport const COMPILER_SLOT_DEFAULT_SLOT_INDEX = 'slotIndex';\n\n\nexport const CompilerSlot: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const element = [document.createComment(COMPILER_SLOT_COMMENT)];\n  const instance: NodeInstance = { parent, component, scope, elements: element };\n\n  if (attrs)\n  {\n    const slotName = attrs.name || DEFAULT_SLOT;\n    const slotIndex = attrs.slotIndex \n      ? scope.eval(attrs.slotIndex)() || 0\n      : 0;\n    const componentSlots = getSlots(component.slots, slotName, slotIndex);\n    const slotOverride = componentSlots.length > 0;\n    const slots = slotOverride\n      ? componentSlots\n      : getSlots(childSlots, slotName, slotIndex);\n    const slotScope = slotOverride\n      ? component.outerScope.createChild()\n      : scope.createChild();\n\n    if (attrs.slotIndex)\n    {\n      const slotOptions = component.getSlotOptions(slotName);\n      const slotIndexName = slotOptions\n        ? slotOptions.arrayIndexAlias || COMPILER_SLOT_DEFAULT_SLOT_INDEX\n        : COMPILER_SLOT_DEFAULT_SLOT_INDEX;\n\n      slotScope.set(slotIndexName, slotIndex);\n    }\n    \n    if (attrs.scope)\n    {\n      for (const scopeKey in attrs.scope)\n      {\n        const scopeValue = attrs.scope[scopeKey];\n\n        if (Scope.isWatchable(scopeValue))\n        {\n          scope.watch(scopeValue, (value) =>\n          {\n            slotScope.set(scopeKey, value, true);\n          });\n        }\n        else\n        {\n          slotScope.set(scopeKey, scopeValue, true);\n        }\n      }\n    }\n\n    if (slots)\n    {\n      const controller = createChildNodes(slots, slotScope, component, instance);\n\n      instance.elements = controller.elements;\n    }\n  }\n\n  return instance;\n};\n\nexport function isComponentSlot(x: any): x is ComponentSlot\n{\n  return isObject(x) && x.scope instanceof Type;\n}","\nimport { isString } from 'expangine-runtime';\nimport { ComponentRegistry } from './ComponentRegistry';\nimport { NodeCompiler, NodeTemplate, NodeInstance, changeElements } from './Node';\nimport { Scope } from './Scope';\nimport { ComponentInstance, ComponentInstanceAny } from './ComponentInstance';\nimport { COMPILER_COMPONENT, COMPILER_DEFAULT, COMPILER_DYNAMIC } from './constants';\nimport { compilers } from './compilers';\n\nexport function getCompiler(template: NodeTemplate): NodeCompiler  \n{\n  const [tag] = template;\n  const key = isString(tag) \n    ? tag in compilers\n      ? tag\n      : tag in ComponentRegistry\n        ? COMPILER_COMPONENT\n        : COMPILER_DEFAULT\n    : COMPILER_DYNAMIC;\n\n  return compilers[key];\n}\n\nexport function compile(template: NodeTemplate, component: ComponentInstanceAny, scope: Scope, parent?: NodeInstance): NodeInstance\n{\n  return getCompiler(template)(template, component, scope, parent);\n}\n\nexport function mount<D>(data: D, template: NodeTemplate, replace?: Node): ComponentInstanceAny\n{\n  const rootScope = new Scope<D>(null, { ...data, refs: {} });\n\n  const instance = new ComponentInstance<any, any, any, any, any>({\n    collection: 'expangine',\n    name: 'mounted',\n    attributes: {},\n    events: {},\n    slots: {},\n    state: {},\n    computed: {},\n    render: () => template,\n  }, {}, rootScope);\n\n  const compiled = compile(template, instance, rootScope);\n\n  if (replace) \n  {\n    changeElements([replace], compiled.elements);\n  }\n\n  instance.node = compiled;\n\n  return instance;\n}","import { Expression, isObject, isString, isArray, ExpressionValue } from 'expangine-runtime';\nimport { DEFAULT_SLOT } from './constants';\nimport { Scope } from './Scope';\nimport { ComponentInstanceAny } from './ComponentInstance';\nimport { compile } from './compile';\n\n\nexport type Off = () => void;\nexport type NodeTemplateTag = string | Expression;\nexport type NodeTemplateValues = Record<string, ExpressionValue>; // when value is Expression, that expression is watched\nexport type NodeTemplateEvents = Record<string, ExpressionValue | ((payload: any) => any)>;\nexport type NodeTemplateChild = string | NodeTemplate | Expression;\nexport type NodeTemplateNamedSlots = Record<string, NodeTemplateChild[] | Record<string, NodeTemplateChild[]>>;\nexport type NodeTemplateSlots = NodeTemplateChild[] | NodeTemplateNamedSlots;\n\nexport type NodeTemplate = [\n  NodeTemplateTag,\n  NodeTemplateValues?,\n  NodeTemplateEvents?,\n  NodeTemplateSlots?\n];\n\n\nexport type NodeCompiler = (template: NodeTemplate, component: ComponentInstanceAny, scope: Scope, parent?: NodeInstance) => NodeInstance;\n\nexport interface NodeInstance \n{\n  parent?: NodeInstance;\n  children?: NodeInstance[];\n  component: ComponentInstanceAny;\n  elements: Node[];\n  scope: Scope;\n}\n\n\nexport function isStyleElement(x: any): x is HTMLElement \n{\n  return !!x && isObject(x.style);\n}\n\nexport function getSlots(slots?: NodeTemplateSlots, name: string = DEFAULT_SLOT, slotIndex: number = 0): NodeTemplateChild[]\n{\n  return !slots\n    ? []\n    : isArray(slots)\n      ? slots\n      : isObject(slots) && isArray(slots[name])\n        ? slots[name]\n        : isObject(slots) && isObject(slots[name]) && isArray(slots[name][slotIndex])\n          ? slots[name][slotIndex]\n          : [];\n}\n\n\nexport function isNamedSlots(value: any): value is NodeTemplateNamedSlots\n{\n  return typeof value === 'object' && !Array.isArray(value);\n}\n\nexport function changeElements(target: Node[], elements: Node[])\n{\n  if (target.length === 0)\n  {\n    target.push(...elements);\n  }\n  else\n  {\n    const parent = target[0].parentNode;\n\n    if (parent)\n    {\n      const removing: Set<Node> = new Set(target);\n      let prev: Node = target[0].previousSibling;\n\n      for (let i = 0; i < elements.length; i++)\n      {\n        const desired = elements[i];\n        const current = prev\n          ? prev.nextSibling\n          : target[i];\n\n        removing.delete(desired);\n\n        if (current !== desired)\n        {\n          if (current)\n          {\n            parent.insertBefore(desired, current);\n          }\n          else if (!prev && parent.firstChild)\n          {\n            parent.insertBefore(desired, parent.firstChild);\n          }\n          else\n          {\n            parent.appendChild(desired);\n          }\n        }\n\n        prev = desired;\n      }\n\n      for (const remove of removing)\n      {\n        parent.removeChild(remove);\n      }\n    }\n\n    target.splice(0, target.length, ...elements);\n  }\n}\n\nexport interface NodeChildrenController\n{\n  elements: Node[];\n  updateScopes( values: any ): void;\n  destroy(): void;\n}\n\nexport function createChildNodes(children: NodeTemplateChild[], scope: Scope, component: ComponentInstanceAny, instance: NodeInstance, sharedScope: boolean = false): NodeChildrenController\n{\n  const elements: Node[] = [];\n  const scopes: Scope[] = [];\n\n  for (const child of children)\n  {\n    if (isString(child)) \n    {\n      elements.push(document.createTextNode(child));\n    } \n    else if (Scope.isWatchable(child))\n    {\n      const textNode = document.createTextNode('');\n\n      scope.watch(child, (text) =>\n      {\n        textNode.textContent = text;\n      });\n\n      elements.push(textNode);\n    }\n    else \n    {\n      const childNode = compile(child, component, scope, instance);\n\n      for (const childElement of childNode.elements)\n      {\n        elements.push(childElement);\n      }\n\n      if (childNode.scope !== scope)\n      {\n        scopes.push(childNode.scope);\n      }\n\n      if (!instance.children)\n      {\n        instance.children = [childNode];\n      }\n      else\n      {\n        instance.children.push(childNode);\n      }\n    }\n  }\n\n  return {\n    elements,\n    updateScopes(values: any) \n    {\n      scope.setMany(values);\n\n      for (const s of scopes) \n      {\n        s.setMany(values);\n      }\n    },\n    destroy() \n    {\n      if (!sharedScope) \n      {\n        scope.destroy();\n      }\n\n      for (const s of scopes) \n      {\n        s.destroy();\n      }\n    },\n  };\n}\n","import { isObject, isFunction, isArray } from 'expangine-runtime';\nimport { NodeCompiler, NodeInstance, getSlots, createChildNodes } from '../Node';\nimport { Scope } from '../Scope';\n\n\nexport interface DefaultEventObject\n{\n  stop: boolean;\n  prevent: boolean;\n  nativeEvent: Event;\n  scope: Scope;\n}\n\nexport const CompilerDefault: NodeCompiler = (template, component, scope, parent) => \n{\n  const [tag, attrs, events, childSlots] = template;\n  const element = document.createElement(tag as any) as HTMLElement;\n  const instance: NodeInstance = { elements: [element], component, scope, parent };\n\n  if (isObject(attrs)) \n  {\n    for (const attr in attrs) \n    {\n      const attrValue = attrs[attr];\n\n      if (Scope.isWatchable(attrValue)) \n      {\n        scope.watch(attrValue, (v) => \n        {\n          applyAttribute(element, attr, v);\n        });\n      }\n      else \n      {\n        applyAttribute(element, attr, attrValue);\n      }\n    }\n  }\n\n  if (isObject(events)) \n  {\n    for (const ev in events) \n    {\n      const eventParts = ev.split('.');\n      const eventName = eventParts.shift();\n      const eventValue = events[eventName];\n    \n      const listenerOptions: AddEventListenerOptions = {\n        once:     hasModifier(eventParts, 'once'),\n        passive:  hasModifier(eventParts, 'passive'),\n        capture:  hasModifier(eventParts, 'capture'),\n      };\n\n      const handler = isFunction(eventValue)\n        ? eventValue\n        : scope.eval(eventValue);\n\n      element.addEventListener(eventName, (nativeEvent) => \n      {\n        for (const modifier of eventParts)\n        {\n          if (modifier in modifierHandlers)\n          {\n            if (!modifierHandlers[modifier](element, nativeEvent))\n            {\n              return;\n            }\n          }\n        }\n\n        const eventObject: DefaultEventObject = {\n          nativeEvent,\n          scope,\n          stop: false,\n          prevent: false,\n        };\n\n        if (handler(eventObject) === false) \n        {\n          return false;\n        }\n\n        for (const modifier in eventObject)\n        {\n          if (eventObject[modifier] && modifier in modifierHandlers)\n          {\n            if (!modifierHandlers[modifier](element, nativeEvent))\n            {\n              return;\n            }\n          }\n        }\n\n      }, listenerOptions);\n    }\n  }\n\n  const childs =  getSlots(childSlots);\n\n  if (childs.length > 0) \n  {\n    const childController = createChildNodes(childs, scope, component, instance);\n\n    for (const child of childController.elements)\n    {\n      element.appendChild(child);\n    }\n  }\n\n  return instance;\n};\n\nconst modifierHandlers: Record<string, (el: HTMLElement, ev: Event) => boolean> = {\n  prevent (el: HTMLElement, ev: Event): boolean {\n    if (ev.preventDefault) {\n      ev.preventDefault();\n    }\n\n    return true;\n  },\n  stop (el: HTMLElement, ev: Event): boolean {\n    if (ev.stopPropagation) {\n      ev.stopPropagation();\n    }\n\n    return true;\n  },\n  self (el: HTMLElement, ev: Event): boolean {\n    return ev.target === el;\n  },\n};\n\nfunction hasModifier(modifiers: string[], modifier: string)\n{\n  const i = modifiers.indexOf(modifier);\n  const exists = i >= 0;\n\n  if (exists)\n  {\n    modifiers.splice(i, 1);\n  }\n\n  return exists;\n}\n\nfunction applyAttribute(e: HTMLElement, attr: string, value: any)\n{\n  if (value === '' || value === null || value === undefined)\n  {\n    if (e.hasAttribute(attr))\n    {\n      e.removeAttribute(attr);  \n    }\n  }\n  else\n  {\n    e.setAttribute(attr, convertToString(value, attr.toLowerCase() === 'style'));\n  }\n}\n\nfunction convertToString(x: any, forStyle: boolean = false): string\n{\n  if (isArray(x))\n  {\n    return x.map((y) => convertToString(y)).join(forStyle ? '; ' : ' ');\n  }\n  else if (isObject(x))\n  {\n    const converted = [];\n\n    for (const prop in x)\n    {\n      if (x[prop] || (forStyle && x[prop] === 0))\n      {\n        converted.push(forStyle\n          ? prop + ': ' + convertToString(x[prop])\n          : prop\n        );\n      }\n    }\n\n    return converted.join(forStyle ? '; ' : ' ');\n  }\n  \n  return String(x);\n}","import { NodeCompiler, NodeInstance, changeElements } from '../Node';\nimport { compile } from '../compile';\nimport { Scope } from '../Scope';\n\n\nexport const CompilerDynamic: NodeCompiler = (template, component, scope, parent) =>\n{\n  const [tag] = template;\n  const instance: NodeInstance = { parent, component, scope, elements: [document.createComment('dynamic')] };\n  let lastScope: Scope;\n\n  scope.watch(tag, (tagValue: any) =>\n  {\n    template[0] = tagValue;\n\n    if (lastScope)\n    {\n      lastScope.destroy();\n    }\n\n    lastScope = scope.createChild();\n\n    const dynamicInstance = compile(template, component, lastScope, parent);\n\n    changeElements(instance.elements, dynamicInstance.elements);\n\n  }, true, true);\n\n  return instance;\n};","import { Exprs, AnyOps, defs } from 'expangine-runtime';\nimport { NodeCompiler, NodeInstance, changeElements, createChildNodes, getSlots, NodeChildrenController, isStyleElement } from '../Node';\nimport { DEFAULT_SLOT } from '../constants';\n\n\nexport type HideAction = 'hide' | 'detach' | 'destroy';\n\nexport const CompilerSwitch: NodeCompiler = (template, component, scope, parent) => \n{\n  const [tag, attrs, , childSlots] = template;\n  const directiveName = (tag as string).substring(1);\n  const placeholder = [document.createComment(directiveName)];\n  const elements: Node[] = placeholder.slice();\n  const instance: NodeInstance = { parent, component, scope, elements };\n  const childScope = scope.createChild();\n  \n  if (attrs && attrs.cases && attrs.value)\n  {\n    const mode: HideAction = attrs.mode || 'detach';\n    const value = defs.getExpression(attrs.value);\n\n    const expr = Exprs.switch(value, attrs.isEqual || AnyOps.isEqual);\n    for (const caseName in attrs.cases) {\n      expr.case(attrs.cases[caseName]).than(caseName);\n    }\n    expr.default(DEFAULT_SLOT);\n\n    let lastVisibleSlot: string;\n    let lastController: NodeChildrenController;\n\n    scope.watch(expr, (slotName) =>\n    {\n      const nextTemplate = getSlots(childSlots, slotName);\n\n      if (nextTemplate.length === 0)\n      {\n        childScope.setEnabled(false);\n\n        switch (mode)\n        {\n          case 'detach':\n            changeElements(instance.elements, placeholder);\n            break;\n\n          case 'destroy':\n            if (lastController) \n            {\n              lastController.destroy();\n              lastController = undefined;\n            }\n\n            changeElements(instance.elements, placeholder);\n            break;\n\n          case 'hide':\n            if (lastController) \n            {\n              const hideElements = instance.elements.slice();\n\n              for (let i = 0; i < hideElements.length; i++) \n              {\n                const hide = hideElements[i];\n\n                if (isStyleElement(hide)) \n                {\n                  hide.style.display = 'none';\n                } \n                else \n                {\n                  hideElements[i] = document.createComment('');\n                }\n              }\n\n              changeElements(instance.elements, hideElements);\n            }\n            break;\n        }\n      }\n      else\n      {\n        if (slotName !== lastVisibleSlot || mode === 'destroy')\n        {\n          if (lastController)\n          {\n            lastController.destroy();\n            lastController = undefined;\n          }\n\n          const nextController = createChildNodes(nextTemplate, childScope, component, instance, true);\n\n          changeElements(instance.elements, nextController.elements);\n\n          lastController = nextController;\n          lastVisibleSlot = slotName;\n        }\n        else if (mode === 'detach')\n        {\n          changeElements(instance.elements, lastController.elements);\n        }\n        else\n        {\n          const showElements = instance.elements.slice();\n\n          for (let i = 0; i < showElements.length; i++) \n          {\n            const show = showElements[i];\n\n            if (isStyleElement(show)) \n            {\n              show.style.display = '';\n            } \n            else \n            {\n              showElements[i] = lastController.elements[i];\n            }\n          }\n\n          changeElements(instance.elements, showElements);\n        }\n\n        childScope.setEnabled(true);\n      }\n\n    }, true, true);\n  }\n  else\n  {\n    throw new Error(`The ${tag} directive requires a cases and value attribute.`);\n  }\n\n  return instance;\n};","import { NodeCompiler } from '../Node';\nimport { COMPILER_DEFAULT, COMPILER_DYNAMIC, COMPILER_COMPONENT, DIRECTIVE_IF, DIRECTIVE_SLOT, DIRECTIVE_FOR, DIRECTIVE_SWITCH } from '../constants';\n\nimport { CompilerDefault } from './default';\nimport { CompilerDynamic } from './dynamic';\nimport { CompilerIf } from './if';\nimport { CompilerComponent } from './component';\nimport { CompilerSlot } from './slot';\nimport { CompilerFor } from './for';\nimport { CompilerSwitch } from './switch';\n\n\nexport const compilers: Record<string, NodeCompiler> = {\n  [COMPILER_DEFAULT]: CompilerDefault,\n  [COMPILER_DYNAMIC]: CompilerDynamic,\n  [COMPILER_COMPONENT]: CompilerComponent,\n  [DIRECTIVE_IF]: CompilerIf,  \n  [DIRECTIVE_SLOT]: CompilerSlot,\n  [DIRECTIVE_FOR]: CompilerFor,\n  [DIRECTIVE_SWITCH]: CompilerSwitch,  \n};\n","import { Type, isObject } from 'expangine-runtime';\nimport { NodeCompiler, isNamedSlots } from '../Node';\nimport { Scope } from '../Scope';\nimport { ComponentRegistry } from '../ComponentRegistry';\nimport { ComponentInstance } from '../ComponentInstance';\nimport { compile } from '../compile';\n\n\nexport const CompilerComponent: NodeCompiler = (template, parentComponent, scope, parent) => \n{\n  const [id, attrs, events, childSlots] = template;\n  const componentBase = ComponentRegistry[id as string];\n  const localScope = new Scope<any>(null, { emit: {}, refs: {} });\n  const component = new ComponentInstance(componentBase, attrs, localScope, isNamedSlots(childSlots) ? childSlots : undefined, parentComponent, scope);  \n  const addRef = attrs?.ref;\n\n  if (addRef)\n  {\n    delete attrs.ref;\n  }\n\n  if (componentBase.attributes)\n  {\n    for (const attr in componentBase.attributes)\n    {\n      const attrValue = componentBase.attributes[attr];\n      const attrObject = attrValue instanceof Type\n        ? { type: attrValue }\n        : attrValue;\n\n      if (attrObject.callable)\n      {\n        continue;\n      }\n\n      const attrInput = attrs && attr in attrs ? attrs[attr] : attrObject.default;\n\n      if (Scope.isWatchable(attrInput))\n      {\n        let first = true;\n\n        scope.watch(attrInput, (v) =>\n        {\n          localScope.set(attr, v, true);\n\n          if (first && attrObject.initial)\n          {\n            attrObject.initial(v, component);\n          }\n          else if (!first && attrObject.changed)\n          {\n            attrObject.changed(v, component);\n          }\n          if (attrObject.update)\n          {\n            attrObject.update(v, component);\n          }\n\n          if (!first && componentBase.updated)\n          {\n            componentBase.updated(component);\n          }\n          \n          first = false;\n        });\n      }\n      else\n      {\n        localScope.set(attr, attrInput, true);\n      }\n    }\n  }\n\n  if (componentBase.state)\n  {\n    for (const stateName in componentBase.state)\n    {\n      const stateValue = componentBase.state[stateName];\n\n      localScope.set(stateName, localScope.eval(stateValue)(), true);\n    }\n  }\n\n  if (componentBase.computed)\n  {\n    for (const computedName in componentBase.computed)\n    {\n      const computedValue = componentBase.computed[computedName];\n\n      localScope.watch(computedValue, (value) => \n      {\n        localScope.set(computedName, value, true);\n      });\n    }\n  }\n\n  if (isObject(events) && componentBase.events) \n  {\n    for (const ev in events) \n    {\n      if (!(ev in componentBase.events))\n      {\n        continue;\n      }\n\n      const eventValue = events[ev];\n\n      if (Scope.isWatchable(eventValue)) \n      {\n        const listener = scope.eval(eventValue);\n\n        component.on(ev, listener);\n      }\n    }\n  }\n\n  const rendered = componentBase.render(component);\n  const instance = compile(rendered, component, localScope, parent);\n\n  component.node = instance;\n\n  if (componentBase.created) \n  {\n    componentBase.created(component);\n  }\n\n  if (addRef && parentComponent)\n  {\n    parentComponent.scope.observed.refs[addRef] = localScope.observed;\n  }\n  \n  return instance;\n};","import { NodeCompiler } from '../Node';\nimport { CompilerSwitch } from './switch';\n\n\nexport const CompilerIf: NodeCompiler = ([tag, attrs, events, childSlots], component, scope, parent) => \n  CompilerSwitch([tag, { value: true, ...attrs }, events, childSlots], component, scope, parent)\n;","import { NodeCompiler, NodeInstance, NodeChildrenController, getSlots, createChildNodes, changeElements } from '../Node';\nimport { Exprs, isArray, isSet, isMap, isObject, isNumber } from 'expangine-runtime';\n\n\nexport const CompilerFor: NodeCompiler = (template, component, scope, parent) => \n{\n  const [, attrs, , childSlots] = template;\n  const placeholder = document.createComment('for');\n  const element = [placeholder];\n  const instance: NodeInstance = { parent, component, scope, elements: element };\n  const itemTemplate = getSlots(childSlots);\n\n  if (attrs && attrs.items)\n  {\n    const propItem = attrs.item || 'item';\n    const propIndex = attrs.index || 'index';\n    const propKey = attrs.key || Exprs.get(propIndex);\n\n    const key = scope.eval(propKey);\n    const map = new Map<any, NodeChildrenController>();\n\n    scope.watch(attrs.items, (items) =>\n    {\n      const newChildren: Node[] = [placeholder];\n      const keys = new Set();\n\n      iterateCollection(items, (item, itemIndex) =>\n      {\n        const itemScopeData = { [propItem]: item, [propIndex]: itemIndex };\n        const itemKey = key({ ...itemScopeData });\n        let itemController = map.get(itemKey);\n\n        if (!itemController)\n        {\n          const itemScope = scope.createChild(itemScopeData);\n\n          itemController = createChildNodes(itemTemplate, itemScope, component, instance);\n\n          map.set(itemKey, itemController);\n        }\n        else\n        {\n          itemController.updateScopes(itemScopeData);\n        }\n\n        keys.add(itemKey);\n        newChildren.push(...itemController.elements);\n      });\n\n      changeElements(instance.elements, newChildren);\n\n      map.forEach((itemController, itemIndex) => \n      {\n        if (!keys.has(itemIndex)) \n        {\n          itemController.destroy();\n\n          map.delete(itemIndex);\n        }\n      });\n    });\n  }\n\n  return instance;\n};\n\nfunction iterateCollection(collection: any, callback: (item: any, index: any) => void)\n{\n  if (isArray(collection))\n  {\n    for (let index = 0; index < collection.length; index++)\n    {\n      callback(collection[index], index);\n    }\n  }\n  else if (isSet(collection))\n  {\n    let index = 0;\n\n    for (const item of collection)\n    {\n      callback(item, index++);\n    }\n  }\n  else if (isMap(collection))\n  {\n    for (const [key, value] of collection.entries())\n    {\n      callback(value, key);\n    }\n  }\n  else if (isObject(collection))\n  {\n    for (const key in collection)\n    {\n      callback(collection[key], collection);\n    }\n  }\n  else if (isNumber(collection))\n  {\n    for (let i = 0; i < collection; i++)\n    {\n      callback(i, i);\n    }\n  }\n}","import { ExpressionValue, Expression, Exprs } from \"expangine-runtime\";\nimport { HideAction } from './compilers/switch';\nimport { NodeTemplate, NodeTemplateChild } from \"./Node\";\nimport { DIRECTIVE_IF, DIRECTIVE_FOR, DIRECTIVE_SLOT, DIRECTIVE_SWITCH } from \"./constants\";\nimport { Component } from \"./Component\";\n\nexport function createIf(condition: ExpressionValue, truthy: NodeTemplateChild[], mode: HideAction = 'detach'): NodeTemplate\n{\n    return createIfs([[condition, truthy]], undefined, mode);\n}\n\nexport function createIfElse(condition: ExpressionValue, truthy: NodeTemplateChild[], falsy: NodeTemplateChild[], mode: HideAction = 'detach'): NodeTemplate\n{\n    return createIfs([[condition, truthy]], falsy, mode);\n}\n\nexport function createIfs(cases: [ExpressionValue, NodeTemplateChild[]][], otherwise?: NodeTemplateChild[], mode: HideAction = 'detach'): NodeTemplate\n{\n    return [DIRECTIVE_IF, {\n        mode,\n        cases: cases.reduce((out, [expr,], key) => (out[key] = expr, out), {}),\n    }, {}, {\n        ...cases.reduce((out, [,tmpl], key) => (out[key] = tmpl, out), {}),\n        default: otherwise,\n    }];\n}\n\nexport function createShow(condition: ExpressionValue, truthy: NodeTemplateChild[]): NodeTemplate\n{\n    return createIfs([[condition, truthy]], undefined, 'hide');\n}\n\nexport function createHide(condition: ExpressionValue, truthy: NodeTemplateChild[]): NodeTemplate\n{\n    return createIfs([[Exprs.not(condition), truthy]], undefined, 'hide');\n}\n\nexport function createSwitch(value: ExpressionValue, cases: [ExpressionValue, NodeTemplateChild[]][], defaultCase?: ExpressionValue, isEqual?: string): NodeTemplate\n{\n    return [DIRECTIVE_SWITCH, {\n        value,\n        cases: cases.reduce((out, [expr,], key) => (out[key] = expr, out), {}),\n        isEqual,\n    }, {}, {\n        ...cases.reduce((out, [,tmpl], key) => (out[key] = tmpl, out), {}),\n        default: defaultCase,\n    }];\n}\n\nexport function createComponent<A, E, S extends string, L, C>(\n    component: Component<A, E, S, L, C>, \n    attributes: Partial<Record<keyof A, ExpressionValue> & { ref: string }> = {}, \n    events: Partial<Record<keyof E, ExpressionValue>> = {}, \n    slots: Partial<Record<S | 'default', NodeTemplateChild[] | Record<string, NodeTemplateChild[]>>> = {}\n): NodeTemplate {\n    return [`${component.collection}/${component.name}`,\n        attributes,\n        events,\n        slots,\n    ];\n}\n\nexport function createFor(items: Expression, children: NodeTemplateChild[], options: { index?: string, item?: string, key?: ExpressionValue } = {}): NodeTemplate\n{\n    return [DIRECTIVE_FOR, {\n        items,\n        ...options,\n    }, {}, \n        children,\n    ];\n}\n\nexport function createSlot(attrs: { name?: string, scope?: Record<string, ExpressionValue>, slotIndex?: ExpressionValue }, children: NodeTemplateChild[] = []): NodeTemplate\n{\n    return [DIRECTIVE_SLOT, attrs, {}, children];\n}\n","\nexport * from './constants';\nexport * from './compilers';\nexport * from './compile';\nexport * from './helpers';\nexport * from './Node';\nexport * from './Scope';\nexport * from './Component';\nexport * from './ComponentInstance';\nexport * from './ComponentRegistry';\n\n"],"sourceRoot":""}